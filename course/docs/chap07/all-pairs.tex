
\begin{frame}{‌کوتاهترین مسیر بین همهٔ جفت‌ها}
\begin{itemize}\itemr
\item[-]
اکنون مسئله کوتاهترین مسیر بین همهٔ جفت رأس‌ها در گراف را بررسی می‌کنیم.
\item[-]
یکی از کاربرهای این الگوریتم، پیدا کردن کوتاهترین مسیر بین هر دو شهر در یک اطلس جغرافیایی است. یکی از کاربردهای دیگر این الگوریتم پیدا کردن فاصلهٔ بین دو نقطه در یک شبکه کامپیوتری برای ارسال بسته‌ها به طور بهینه است.
\item[-]
خروجی الگوریتم یک جدول به اندازهٔ
\m{|V| \times |V|}
است که در سطر
\m{u}
و ستون
\m{v}
فاصله بین شهر
\m{u}
و شهر
\m{v}
را باز می‌گرداند.
\end{itemize}
\end{frame}


\begin{frame}{‌کوتاهترین مسیر بین همهٔ جفت‌ها}
\begin{itemize}\itemr
\item[-]
یک راه حل ساده این است که به ازای هر یک از رئوس گراف، آن رأس را مبدأ فرض کرده و الگوریتم کوتاهترین مسیر از رأس مبدأ را از هریک از رئوس گراف اجرا کنیم تا فاصله بین همهٔ رئوس به دست بیاید برای مثال اگر وزن یال‌ها مثبت باشند، می‌توان از الگوریتم دایکسترا به تعداد
\m{|V|}
بار استفاده کرد که در مجموع کل محاسبات در زمان
\m{O(|V|^3)}
 اجرا می‌شود.
اگر صف اولویت در الگوریتم دایکسترا توسط هرم فیبوناچی پیاده‌سازی شود، زمان اجرا به
\m{O(|V|^2 lg |V| + |V||E|)}
کاهش پیدا می‌کند.
البته در بدترین حالت 
\m{|E| = O(|V|^2)},
بنابراین زمان اجرای الگوریتم یافتن کوتاهترین مسیر بین همه جفت رئوس با استفاده از الگوریتم دایکسترا برابر است با 
\m{O(|V|^3)} .
\item[-]
اگر گراف یال‌هایی با وزن منفی داشته باشد، نمی‌توان از الگوریتم دایکسترا استفاده کرد. می‌توانیم در این‌صورت با استفاده از الگوریتم بلمن-فورد، کوتاهترین مسیر بین همهٔ جفت‌ها را در زمان
\m{O(|V|^2 |E|)}
محاسبه کنیم که در صورتی که گراف متراکم باشد، زمان اجرا برابر خواهد بود با
\m{O(|V|^4)} .
\end{itemize}
\end{frame}


\begin{frame}{‌کوتاهترین مسیر بین همهٔ جفت‌ها}
\begin{itemize}\itemr
\item[-]
در این قسمت الگوریتمی ارائه می‌کنیم که کوتاهترین مسیر بین همهٔ رئوس را در زمان کمتری محاسبه کند.
\item[-]
برای استفاده از این الگوریتم، گراف را با استفاده از ماتریس مجاورت نشان می‌دهیم.
\end{itemize}
\end{frame}


\begin{frame}{‌کوتاهترین مسیر بین همهٔ جفت‌ها}
\begin{itemize}\itemr
\item[-]
اگر رأس‌ها را با شماره‌های ۱، ۲، ... ،
\m{|V|}
شماره گذاری کنیم، به طوری‌که تعداد رئوس برابر با
\m{n}
باشد، آنگاه یک ماتریس
\m{n \times n}
که با
\m{W = (w_{ij})}
نشان می‌دهیم، وزن یال‌ها را در گراف
\m{G = (V,E)}
نشان می‌دهد، به طوری‌که
\begin{align*}
\m{w_{ij}} = \left\{\begin{array}{llr}
          \m{0}& \m{i = j}&\text{اگر}\\
          \m{w(i,j)}&\m{(i,j) \in E}~\text{و}~\m{i \neq j}&\text{اگر}\\
          \m{\infty}&\m{(i,j) \notin E}&\text{اگر}
\end{array}\right.
\end{align*}
\item[-]
خروجی الگوریتم یک جدول
\m{n \times n}
خواهد بود به طوری‌که در سطر
\m{i}
و ستون
\m{j}
مقدار
\m{\delta(i,j)}
قرار گیرد.
\item[-]
خروجی الگوریتم کوتاهترین مسیر می‌تواند شامل یک ماتریس رئوس ماقبل
\fn{1}{predecessor matrix}
به نام
\m{\Pi = (\pi_{ij})}
نیز باشد که در آن
\m{\pi_{ij}}
رأس پدر (ماقبل) رأس
\m{j}
را بر روی مسیری که از رأس
\m{i}
آغاز شده نشان می‌دهد. در صورتی که
\m{i = j}
باشد یا هیچ مسیری از
\m{i}
به
\m{j}
وجود نداشته باشد، آنگاه
\m{\pi_{ij}}
برابر با
\code{NIL}
خواهد بود.
\end{itemize}
\end{frame}


\begin{frame}{‌کوتاهترین مسیر بین همهٔ جفت‌ها}
\begin{itemize}\itemr
\item[-]
برای چاپ کوتاهترین مسیر از
\m{i}
به
\m{j}
با استفاده از ماتریس رئوس ماقبل می‌توانیم از الگوریتم زیر استفاده کنیم.
\begin{algorithm}[H]\alglr
  \caption{Print-All-Pairs-Shortest-Path} 
  \begin{algorithmic}[1]
   \Func{Print-All-Pairs-Shortest-Path}{\mc{\Pi},i,j}
   \If{i == j}
   		\State print i
   \ElsIf{\mc{\pi_{ij}} == NIL}
   		\State print "no path from" i "to" j "exists"
   \Else
        \State Print-All-Pairs-Shortest-Path(\mc{\Pi},i,\mc{\pi_{ij}})
   		\State print j
   \EndIf                           
  \end{algorithmic}
  \label{alg:merge}
\end{algorithm}
\end{itemize}
\end{frame}