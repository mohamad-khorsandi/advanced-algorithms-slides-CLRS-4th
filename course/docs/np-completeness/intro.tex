\begin{itemframe}{مقدمه}
\itm
تقریباً همه الگوریتم‌هایی تا به حال بررسی کردیم، الگوریتم‌های زمان چند جمله‌ای
\fn{polynomial-time algorithm}
 بودند بدین معنی که به ازای ورودی با اندازهٔ
$n$
، زمان اجرای آنها در بدترین حالت به ازای هر ثابت
$k$
برابر است با
$O(n^k)$ .
\itm
شاید تصور کنید زمان چند جمله‌ایی مانند
$\Theta(n^{100})$
آنقدر بزرگ است که هر مسئله‌ایی در این زمان قابل حل باشد. اما مسائلی وجود دارند که در زمان چند جمله‌ای قابل حل نیستند.
\itm
حتی برخی مسائلی نه تنها در زمان چند جمله‌ایی‌ بلکه توسط هیچ الگوریتمی قابل محاسبه نیستند.
مانند مسئلهٔ توقف ماشین تورینگ
\fn{halting problem}
یا مسئلهٔ دهم هیلبرت (حل‌پذیری معادلات سیاله
\fn{diophantine equations}
)،
می‌گوییم.
\end{itemframe}

%----------------------------------------------------
\begin{itemframe}{مقدمه}
\itm
وجود راه حل در زمان چند جمله‌ایی برای ما مطلوب است.
\sub
به طوری که مسائلی که در زمان چند جمله‌ای قابل حل‌اند، آسان تلقی می‌شوند و به آنها مسائل قابل کنترل
\fn{tractable}
 گفته می‌شود.
\sub
 همچنین مسائلی که در این زمان قابل محاسبه نیستند، سخت تلقی می‌شوند و به آنها غیر قابل کنترل
\fn{intractable}
گفته می‌شود.
\end{itemframe}

%----------------------------------------------------
\begin{itemframe}{مقدمه}
\itm
اما موضوع این فصل دسته‌ای جالب از مسائل به نام ان‌پی کامل
\fn{NP-complete problems}
است که پیچیدگی محاسباتی آن‌ها نامعلوم است.

\itm
هیچ الگوریتم چند جمله‌ای برای این دسته از مسائل تاکنون پیدا نشده است و کسی نتوانسته اثبات کند که هیچ الگوریتم چند جمله‌ای برای آنها وجود ندارد.
\itm
جمله بالا بیانی از مسئلهٔ پی در برابر ان‌پی
\fn{P vs. NP}
است؛ یکی از مهم‌ترین مسائل علوم کامپیوتر که در سال ۱۹۷۱ مطرح شده و تا به حال حل نشده باقی مانده است.
\end{itemframe}

%----------------------------------------------------
\begin{itemframe}{مقدمه}
\itm
برخی از مسائل ان‌پی کامل بسیار شبیه مسائلی هستند که راه حل چند جمله‌ایی برای آنها یافت شده. در ادامه تعدادی از مسائل را می‌بینیم که با وجود شباهت ظاهری‌شان برای یکی از آنها الگوریتم چند جمله‌ای وجود دارد و دیگری ان‌پی کامل است.
\itm
\textbf{«کوتاهترین مسیر» و «بلندترین مسیر»:}
با این که این دو مسئله بسیار شبیه یکدیگرند، اما برای مسئله کوتاهترین مسیر در گراف یک الگوریتم چند جمله‌ای وجود دارد که در زمان
$O(|V||E|)$
 اجرا می‌شود، اما برای مسئله بلندترین مسیر تا به حال الگوریتم چند جمله‌ایی یافت نشده همچنین اثبات نشده که راه حل چند جمله‌ایی برای آن وجود ندارد بنابراین یک مسئلهٔ ان‌پی کامل است.
\end{itemframe}

%----------------------------------------------------
\begin{itemframe}{مقدمه}
\itm
\textbf{«دور اویلری» و «دور همیلتونی»:}
دور اویلری
\fn{Eulerian cycle}
در یک گراف دوری است که از هر یال دقیقا یک بار عبور می‌کند. این دور می‌تواند از هر رأس چندبار عبور کند. این مسئله در زمان
$O(|E|)$
برای گراف
$G(V,E)$
قابل حل است. دور همیلتونی
\fn{Hamiltonian cycle}
 دوری است که از هر رأس دقیقا یک‌بار عبور می‌کند. این مسئله یک مسئله ان‌پی کامل است.
\end{itemframe}

%----------------------------------------------------
\begin{itemframe}{مقدمه}
\itm
\textbf{«صدق‌پذیری ۲ تایی» و «صدق پذیری ۳ تایی»: }
عبارات منطقی شامل متغیرهای منطقی هستند که مقدار آنها می‌تواند صفر یا یک باشد. این متغیرها به عنوان عملوند با تعدادی عملگر منطقی عبارات منطقی را می‌سازند. عملگرهای منطقی شامل عملگر عطف
\fn{conjunction}
$(\wedge)$
، عملگر فصل
\fn{disjunction}
$(\vee)$
و عملگر نقیض
\fn{negation}
$(\sim)$
می‌شوند.
\sub
یک عبارت صدق پذیر
\fn{safisfiable}
است اگر با انتساب مقادیر صفر و یک به متغیرهای عبارت، مقدار عبارت برابر با ۱ شود. یک عبارت به صورت فرم نرمال عطفی k تایی است اگر آن عبارت از عطف چندین عبارت تشکیل شده باشد که هر یک از آن عبارات از فصل k متغیر یا نقیض متغیر تشکیل شده باشند.
\sub
مسئلهٔ صدق پذیری ۲ تایی در واقع تعیین صدق پذیری یک عبارت به صورت فرم نرمال ۲ تایی است. گرچه برای مسئلهٔ صدق پذیری ۲ تایی الگوریتم چندجمله‌ای وجود دارد، اما صدق‌پذیری ۳ تایی ان‌پی کامل است.
\end{itemframe}

%----------------------------------------------------
\begin{itemframe-s}{مقدمه}{طبقه بندی مسائل}
\itm
در طول این فصل با این سه دسته مسئله سروکار خواهیم داشت: پی، ان‌پی و ان‌پی کامل. در این بخش به صورت مختصر با این کلاس‌های آشنا خواهیم شد. در آینده این کلاس‌ها را دقیق‌تر تعریف و بررسی می‌کنیم.
\itm
پی مخفف زمان چند جمله‌ایی است
\fn{polynomial time}
 و کلاس پی
\fn{class P}
شامل مسائلی است که در زمان چند جمله‌ای قابل حل هستند.
\itm
ان‌پی مخفف چند جمله‌ایی غیر قطعی
\fn{Non-deterministic Polynomial time}
 است و کلاس ان‌پی
\fn{class NP}
شامل مسائلی است که در زمان چند جمله‌ای قابل تصدیق
\fn{verifiable}
هستند، بدین معنی که اگر یک مقدار به عنوان جواب داده شود، در زمان چند جمله‌ای می‌توان بررسی کرد که آیا مقدار داده شده یک جواب درست است یا خیر.

\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{مقدمه}{طبقه بندی مسائل}
\itm
برای مثال اگر برای یک گراف یک دور داده شود، می‌توان در زمان چند جمله‌ای بررسی کرد آیا دور داده شده همیلتونی است یا خیر. کافیست بررسی کنیم همه رأس‌ها دقیقا یک بار در دور وجود داشته باشند. پس مسئله دور همیلتونی ان‌پی است.
\itm
هر مسئله در کلاس پی به کلاس ان‌پی نیز تعلق دارد، زیرا اگر یک مسئله در زمان چند جمله‌ای قابل حل باشد، در زمان چند جمله تصدیق‌پذیر نیز هست. بنابراین می‌توان بگوییم
$P \subseteq NP$.
\itm
مسئله مشهور پی در مقابل ان‌پی
\fn{P vs NP}
می‌پرسد آیا کلاس پی و ان‌پی برابرند یا خیر. به عبارت دیگر «آیا مسائلی که در زمان چند جمله‌ای قابل تصدیق هستند، در زمان چند جمله‌ای قابل حل هستند؟»
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{مقدمه}{طبقه بندی مسائل}
\itm
یک مسئله به دستهٔ مسائل ان‌پی کامل
\fn{NP-complete}
تعلق دارد اگر عضو کلاس ان‌پی باشد و جزو سخت‌ترین مسائل این کلاس باشد. در آینده منظور از این تعریف را بیشتر شرح خواهیم داد.
\itm
مسائل NP کامل ویژگی مهمی دارد: اگر یکی از این مسائل در زمان چند جمله‌ایی حل شود نتیجه می‌شود که همه آنها در زمان چند جمله‌ایی حل می‌شوند.
 \itm
بنابراین دانشمندان علوم کامپیوتر در بسیاری در طول تاریخ تلاش کردند تا یک راه حل چند جمله‌ایی حداقل برای یکی از این مسائل بیابند اما هیچ الگوریتم چند جمله‌ایی برای این مسائل یافت نشده.
 \itm
از طرف دیگر برای هیچ کدام از مسائل ثابت نشده که راه حل چند جمله‌ایی برای آن وجود ندارند.
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{مقدمه}{طبقه بندی مسائل}
\itm
امّا شناخت مسائل ان‌پی کامل چه کمکی به ما می‌کند؟
\itm
به عنوان یک طراح الگوریتم، اگر بتوانید ثابت کنید که یک مسئله ان‌پی کامل است، به احتمال زیاد به راحتی برای آن الگوریتم چندجمله‌ای پیدا نخواهید کرد، بنابراین بهتر است تمرکز خود را بر روی پیدا کردن یک الگوریتم تقریبی خوب بگذارید یا مسئله را برای حالت‌های خاص حل کنید.
\itm
به عنوان یک مهندس اگر ثابت کنید یک مسئله ان‌پی کامل است، در واقع می‌توانید سختی آن مسئله را نشان دهید و نشان دهید جستجو برای یک الگوریتم چندجمله‌ای به احتمال بسیار زیاد بی ثمر خواهد بود.
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{مقدمه}{اثبات ان‌پی کامل بودن}
\itm
اگر بتوانیم نشان دهیم یک مسئله NP-کامل است، می‌توانیم دربارهٔ «سخت بودن» آن مسئله اظهارنظر می‌کنیم. زیرا در این صورت، جستجو برای یافتن الگوریتمی کارا برای آن احتمالاً بی‌ثمر خواهد بود.
\itm
بنابراین اثبات ان‌پی کامل بودن حائز اهمیت است. برای نشان دادن اینکه یک مسئله ان‌پی کامل است، از این سه مفهوم استفاده می‌کنیم: ۱) مسائل تصمیم گیری ۲) کاهش ۳) اهمیت یافتن اولین مسئله ان‌پی کامل
\itm
در ادامهٔ این مفاهیم را معرفی خواهیم کرد.
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{مقدمه‌}{مسائل تصمیم‌گیری}
\itm
بسیاری از مسئله‌ها، مسائل بهینه سازی
\fn{optimization problem}
هستند و هدف از حل این مسائل یافتن مقداری است که از جواب‌های دیگر بهتر (کوچکتر، بزرگتر، ...) است. برای مثال مسئله کوتاهترین مسیر، یک مسئلهٔ بهینه سازی است، زیرا در میان همهٔ مسیرهای ممکن، هدف پیدا کردن مسیری است که طول آن از همه کمتر است.
\itm
مسائل ان‌پی کامل مسائل بهینه سازی نیستند، بلکه مسائل تصمیم‌گیری
\fn{decision problem}
هستند. در این‌گونه مسائل جواب بله و خیر است.
\itm
با این حال مسائل بهینه‌سازی قابل تبدیل به مسائل تصمیم‌گیری هستند. برای مثال نسخه تصمیم‌گیری مسئله کوتاه‌ترین مسیر بین و این چنین است: آیا مسیری با طول k از u به v وجود دارد یا خیر.
%todo complete here
\itm
سختی یک مسئله بهینه‌سازی بیشتر یا مساوی با سختی مسئله تصمیم‌گیری متناظر است. پس اگر نشان دهیم یک مسئلهٔ تصمیم‌گیری ان‌پی کامل است، مسئلهٔ بهینه‌سازی متناظر با آن ....
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{مقدمه}{کاهش}
\itm
حال می‌خواهیم نشان دهیم که یک مسئله از مسئلهٔ دیگر سخت‌تر نیست.
\itm
معمولاً یک مسئله در حالت کلی توسط تعدادی پارامتر بیان می‌شود. وقتی پارامترهای یک مسئله را مقداردهی می‌کنیم در واقع یک نمونه
\fn{intance}
از مسئله را به دست آورده‌ایم.
\itm
برای مثال مسئلهٔ کوتاهترین مسیر می‌پرسد به ازای یک گراف دلخواه و دو رأس u و v چگونه کوتاهترین مسیر را در حالت کلی پیدا کنیم. یک نمونه از مسئله درواقع یک گراف معین و دو رأس ورودی و خروجی معین است.
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{مقدمه}{کاهش}
\itm
مسئلهٔ تصمیم‌گیری A را در نظر بگیرید که می‌خواهید آن را در زمان چندجمله‌ای حل کنید.
\itm
فرض کنید می‌دانید چگونه مسئله B را در زمان چند‌جمله‌ای حل کنید.
\itm
همچنین فرض کنید می‌دانید چگونه هر نمونه
$\alpha$
از مسئله A رابه نمونهٔ
$\beta$
از مسئلهٔ B تبدیل کنید به طوری‌که :\\
۱. تبدیل نمونه
$\alpha$
به نمونه
$\beta$
در زمان چند‌جمله‌ای انجام شود.\\
۲. جواب نمونه مسئله تصمیم‌گیری
$\alpha$
بله باشد اگر و تنها اگر جواب نمونه مسئلهٔ تصمیم‌گیری
$\beta$
بله باشد.
\itm
چنین روندی برای تبدیل مسئله‌های تصمیم‌گیری به یکدیگر را الگوریتم کاهش در زمان چندجمله‌ای
\fn{polynominal time reduction algorithm}
می‌نامیم.
\itm
اگر B در زمان چندجمله‌ای قابل حل باشد و A در زمان چندجمله‌ای قابل کاهش به B باشد، آنگاه برای حل مسئلهٔ A در زمان چندجمله‌ای کافی است آن را در زمان چندجمله‌ای به B کاهش دهیم و سپس B را در زمان چندجمله‌ای حل کنیم.
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{مقدمه}{کاهش}
\itm
الگوریتم کاهش در زمان چندجمله‌ای در واقع روشی برای حل مسئله A در زمان چند‌جمله‌ای است.\\
۱. به ازای نمونه
$\alpha$
از مسئله A ، از الگوریتم کاهش در زمان چندجمله‌ای برای تبدیل آن به نمونه
$\beta$
از مسئله B استفاده می‌کنیم.\\
۲. مسئله تصمیم‌گیری B را برای نمونه
$\beta$
در زمان چندجمله‌ای حل می‌کنیم.\\
۳. جواب نمونه
$\beta$
را به عنوان جواب نمونه
$\alpha$
در نظر می‌گیریم.
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{مقدمه}{کاهش}
\itm
شکل زیر الگوریتم کاهش برای حل یک مسئله را نشان می‌دهد.
\pic[.9]{1046-reduction}
\end{itemframe}

%----------------------------------------------------
\begin{itemframe-s}{مقدمه}{کاهش}
\itm
پس با استفاده از روش کاهش برای حل مسئله A از الگوریتم چندجمله‌ای مسئله B استفاده می‌کنیم.
%\itm
%پس آسان بودن مسئلهٔ B روشی آسان برای حل مسئله A ارائه می‌دهد.
\itm
به طور کلی اگر A به B کاهش یابد نتیجه می‌شود مقدار سختی ‌B بیشتر یا مساوی با A است.
\itm

از همین ایده استفاده می‌کنیم برای اینکه نشان دهیم یک مسئله به سختی یک مسئلهٔ دیگر است.
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{مقدمه}{کاهش}
\itm
فرض کنید ثابت شده‌است که برای مسئله A الگوریتم چندجمله‌ای وجود ندارد. حال فرض کنید یک الگوریتم کاهش در زمان چندجمله‌ای برای تبدیل یک نمونه از مسئله A به یک نمونه از مسئله B وجود دارد. می‌توانیم با استفاده از برهان خلف نشان دهیم که هیچ الگوریتم چندجمله‌ای برای B وجود ندارد.
\itm
برای اثبات این قضیه فرض کنید برای B یک الگوریتم چندجمله‌ای وجود داشته باشد، در آن صورت می‌توانستیم با استفاده از کاهش، یک الگوریتم چندجمله‌ای برای A پیدا کنیم، اما می‌دانیم ثابت شده است که الگوریتم چندجمله‌ای برای A وجود ندارد. پس به تناقض می‌رسیم و در نتیجه فرض اولیه نادرست بوده و الگوریتم چندجمله‌ای برای ‌B وجود ندارد.
\end{itemframe-s}
%----------------------------------------------------
\begin{itemframe-s}{مقدمه}{کاهش}
\itm
برای اینکه نشان دهیم B ان‌پی کامل است از همین روند استفاده می‌کنیم. اگرچه نمی‌توانیم به طور قطعی بگوییم که هیچ الگوریتم چندجمله‌ای برای A وجود ندارد، اما می‌توانیم اثبات کنیم B ان‌پی کامل است با فرض اینکه A ان‌پی کامل است.
پس برای اثبات ان‌پی کامل بودن یک مسئله باید یکی از مسائل ان‌پی‌کامل را در زمان چندجمله‌ای به آن مسئله کاهش دهیم.
%todo A should proved to np in advanced
می‌گوییم مسئلهٔ B به سختی مسئلهٔ A است.
\itm
برای اینکه ثابت کنیم یک مسئله در کلاس ان‌پی کامل است باید از همه مسائل کلاس ان‌پی به آن کاهش انجام دهیم. می‌توانید حدس بزنید این کار چقدر مشکل است؛ تعداد مسائل ان‌پی کامل نامتناهی است و تبدیل هر کدام به یک مسئله دیگر نیز کار مشکلی است(برای مثال به این فکر کنید که چگونه می‌توان با حل مسئله طولانی ترین مسیر و انجام یک پردازش چند جمله‌ایی یک الگوریتم برای مسئله ارضاء پذیری ابداء کنیم.)
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{مقدمه}{کاهش}
\itm
امّا اگر تنها یک مسئله ثابت ان‌پی کامل داشته باشیم برای اثبات ان‌پی کامل بودن مسائل بعدی کافیست از مسئله اثبات شده به مسئله جدید یک کاهش بیابیم.
\itm
اولین مسئله‌ای که ان‌پی کامل بودن آن اثبات شده است، مسئلهٔ ارضاء پذیری است.
برای اثبات اولین مسئله اثبات شد که همهٔ مسائل ان‌پی در زمان چندجمله‌ای قابل کاهش به مسئلهٔ صدق‌پذیری هستند. بنابراین اگر مسئلهٔ صدق‌پذیری در زمان چندجمله‌ای حل شود، همهٔ مسائل ان‌پی در زمان چندجمله‌ای حل خواهند شد. به عبارت دیگر مسئلهٔ صدق‌پذیری به سختی همهٔ مسائل ان‌پی است.
\itm
در واقع هر یک از مسائل ان‌پی‌کامل به سختی همهٔ مسائل ان‌پی است، زیرا حل یکی از آنها در زمان چندجمله‌ای منجر به حل همهٔ مسائل ان‌پی می‌شود.
\end{itemframe-s}
