\begin{itemframe}{کلاس ان‌پی کامل}
\itm
شاید قانع‌کننده‌ترین دلیلی که میبنی بر مخالف بودن کلاس پی و ان‌پی وجود دارد وجود کلاس ان‌پی کامل است. این کلاس ویژگی بسیار جالبی دارد: اگر یکی از اعضای این کلاس در زمان چند جمله‌ایی حل شود آنگاه ثابت می‌شود همه آنها الگوریتم چند جمله‌ایی دارند. و بنابراین پی برابر می‌شود با ان‌پی.
\itm
برخلاف دهه‌ها تلاش محققان برای هیچ کدام از مسائل ان‌پی کامل راه حل چند جمله‌ایی یافت نشده.
\itm
مسائل کلاس ان‌پی کامل «سخت‌ترین» مسائل کلاس ان‌پی است بنابراین اگر ثابت شود که
$NP - P$
خالی نیست مسائل دسته ان‌پی کامل به قطع در این فضا قرار می‌گیرند.

\end{itemframe}

%----------------------------------------------------
\begin{itemframe}{کلاس ان‌پی کامل}
\itm
در این بخش می‌خواهیم مسائل ان‌پی کامل را به طور دقیق‌تر تعریف کنیم. همانطور که گفته شد این دسته شامل سخت ترین مسائل ان‌پی است امّا سخت بودن یعنی چه؟ چگونه می‌توان عنوان کرد مسئله‌ایی از دیگری سخت‌تر است؟
\itm
عبارت «سخت‌ بودن»
\fn{hardness}
که چندین بار در این مبحث (از جمله در توضیح کلاس ان‌پی کامل) از آن استفاده کردیم ممکن است مبهم و غیر دقیق به نظر برسد امّا این عبارت در واقع تعریف دقیق و مشخصی دارد و هدف آن مقایسه مسائل را از دیدگاه پیچیدگی زمانی است.
\itm
همانطور که قبلاً اشاره کوتاهی انجام شد، مقایسه سختی مسائل  از طریق کاهش به دست می‌آید. بنابراین برای تعریف رسمی کلاس ان‌پی کامل باید ابتدا مبحث کاهش پذیری را دقیق‌تر بررسی کنیم.
\end{itemframe}

%----------------------------------------------------
\begin{itemframe-s}{کلاس ان‌پی کامل}{کاهش پذیری}
\itm
می‌گوییم مسئله A به B کاهش پذیر
\fn{reducible}
 است اگر هر نمونه از A مثل a قابلیت تبدیل به یک نمونه از B مانند b را داشته باشد به طوری که با حل نمونه b پاسخ a نیز به دست بیاید.
\itm
برای مثال مسئله حل معادله درجه می‌تواند به حل معادله درجه دو کاهش یابد. فرض کنید $ax+b=0$ یک نمونه از معادله درجه یک باشد می‌دانیم که پاسخ آن
$ x = -b/a $
است.
آنگاه با حل این معادله $ ax^2+bx+0=0 $ می‌توان جواب معادله درجه یک اولیه را به دست آورد. (با توجه به اینکه c صفر است جواب‌های این معادله عبارت‌اند از
$ x_1 = 0, x_2= -b/a $
)

\itm
نتیجه کاهش مسئله A به B در حالت کلی این است که A نمی‌تواند از B سخت‌تر باشد. همانطور که در این مثال از انجام این کاهش می‌توان نتیجه گرفت که حل مسئله معادله درجه یک نمی‌تواند از درجه دو سخت‌تر باشد.
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{کلاس ان‌پی کامل}{کاهش پذیری}
\itm
با استفاده از چارچوبی که در تئوری زبان‌های صوری با آن آشنا شدیم می‌توانیم مفهوم مهمی تحت عنوان «کاهش پذیری در زمان چند جمله‌ایی»
\fn{polynomial-time reducible}
را تعریف کنیم.
\itm
می‌گوییم زبان $ L_1 $ در زمان چند جمله‌ایی به $ L_2 $  کاهش پذی است  اگر تابعی مثل f وجود داشته باشد که در زمان چند جمله‌ایی نمونه‌های $ L_1 $ را به نمونه‌های $ L_2 $ تبدیل کند. آنگاه به این تابع، تابع کاهش
\fn{reduction function}
و به الگوریتم آن الگوریتم کاهش
\fn{reduction algorithm}
گفته می‌شود.
\itm
اگر زبان $ L_1 $ در زمان چند جمله‌ایی به $ L_2 $ کاهش یابد، آن را به این صورت می‌نویسیم:
\begin{align*}
L_1 \leq_p L_2
\end{align*}
 این نحو نوشتار به خوبی گویای مفهوم کاهش است.
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{کلاس ان‌پی کامل}{کاهش پذیری}
\itm
یک تابع کاهش به این صورت زبانی مثل
$L_1$
را به زبان دیگر مانند
$L_2$
کاهش می‌دهد:
\centerimg{figs/np-completeness/6.png}
 \itm
در این شکل تابع f هر عضو از زبان  $ L_1 $ را به یک عضو از $ L_2 $ نگاشت می‌کند و در صورتی که زبانی عضو  $ L_1 $  نباشد $ f(L_1)$ عضو $ L_2 $ نخواهد بود.
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{کلاس ان‌پی کامل}{کاهش پذیری}
\itm
کاهش چندجمله‌ای ابزاری قدرتمندی برای اثبات تعلق به کلاس $P$ در اختیار ما قرار می‌دهد.
\itm
به طوری که اگر
$L_1, L_2 \subseteq {0,1}^*$
دو زبان باشند به‌طوری‌که
$L_1 \leq_P L_2$
، آنگاه
$L_2 \in P$
 نتیجه می‌دهد که
$L_1 \in P$
نیز برقرار است.
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{کلاس ان‌پی کامل}{تعریف ان‌پی کامل بودن}
\itm
با استفاده از کاهش چندجمله‌ای می‌توانیم نشان دهیم یک مسئله حداقل به سختی مسئله‌ای دیگر است، تا حدی که تفاوت سختی آن‌ها تنها در یک چندجمله‌ای باشد.
\itm
 به بیان دقیق‌تر، اگر
 $L_1 \leq_P L_2$
، آنگاه
$L_1$
 حداکثر به اندازهٔ یک مقدار چندجمله‌ای سخت‌تر از
$L_2$
 است. نماد «$\leq$» در کاهش به خوبی نشان دهنده نسبت سختی دو مسئله است.

\itm
اکنون می‌توانیم مجموعهٔ زبان‌های ان‌پی کامل را تعریف کنیم، که سخت‌ترین مسائل در کلاس NP هستند.

یک زبان مانند L ان‌پی کامل است اگر:
\item[1]
$L \in NP$
\item[2]
از همه زبان‌های عضو NP  به L کاهش وجود داشته باشد.
\end{itemframe-s}


%----------------------------------------------------
\begin{itemframe-s}{کلاس ان‌پی کامل}{تعریف ان‌پی کامل بودن}
\itm
اگر یک زبان $L$ خاصیت ۲ را داشته باشد، اما \textbf{الزاماً} خاصیت ۱ را نداشته باشد، می‌گوییم که
 $L$
ان‌پی سخت
\fn{NP-hard}
 است.
\itm
ان‌پی کامل بودن نقش مهمی در مسئله
$P = NP$
دارند. در زیر دلایل این مسئله را بررسی می‌کنیم:
\item[1]
اگر هرکدام از مسئلهٔ ان‌پی کامل در زمان چندجمله‌ای قابل حل باشد، ثابت می‌شود $P = NP$.
\item[2]
 اگر یک مسئله مانند A در
$NP$
وجود داشته باشد که ثابت شود در زمان چندجمله‌ای قابل حل نیست، آنگاه هیچ مسئلهٔ ان‌پی کاملی در زمان چندجمله‌ای قابل حل نخواهد بود. زیرا A عضو ان‌پی است پس سختی آن از همه مسائل ان‌پی کامل بیشتر یا مساوی با آنهاست.
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{کلاس ان‌پی کامل}{تعریف ان‌پی کامل بودن}
\itm
به همین دلیل است که پژوهش‌ها دربارهٔ پرسش
$P \stackrel{?}{=} NP$
عمدتاً بر مسائل ان‌پی کامل متمرکز هستند.
\itm
بیشتر نظریه‌پردازان علوم کامپیوتر بر این باورند که
$P \ne NP$
،بنابراین این سه کلاس به این صورت قرار می‌گیرند: (
$NPC$
مخفف ان‌پی کامل است)
\centerimg[.4]{figs/np-completeness/7.png}
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{کلاس ان‌پی کامل}{مسئله ارضاء پذیری مدار}
\itm
ما تاکنون مسائل ان‌پی کامل را تعریف کرده‌ایم، اما ان‌پی‌ کامل بودن هیچ مسئله‌ای را اثبات نکرده‌ایم.
\itm
زمانی که ان‌پی‌ کامل بودن یک مسئله را اثبات کنیم، با استفاده از کاهش‌پذیری در زمان چندجمله‌ای ابزاری قدرتمند برای اثبات ان‌پی‌ کامل بودن سایر مسائل در اختیار خواهیم داشت.
\itm
از این‌رو، اکنون تمرکز خود را بر نشان دادن وجود یک مسئلهٔ ان‌پی کامل قرار می‌دهیم: مسئلهٔ ارضاء‌پذیری مدار
\fn{circuit satisfiability} .
\itm
اثبات رسمی ان‌پی‌ کامل بودن مسئلهٔ رضایت‌پذیری مدار شامل جزئیاتی می‌شود که فراتر از بحث ما است. در عوض، یک اثبات غیر رسمی مبتنی بر مدارات منطقی ترکیبی بیان خواهیم کرد.
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{کلاس ان‌پی کامل}{مسئله ارضاء پذیری مدار}
\itm
می‌خواهیم ثابت کنیم مسئلهٔ ارضاء‌پذیری مدار متعلق به کلاس ان‌پی است.

%certificate needs to be defined in pervious slides
\itm
باید یک الگوریتم A با زمان اجرای چندجمله‌ای ارائه ‌دهیم که یک گواه (در اینجا یک مقدار دهی به ورودی‌های مدار ترکیبی) و یک مدار دریافت کند و بررسی کند آیا خروجی مدار ۱ است یا خیر.

%todo ask : the book here assumes an easier but non sense certificate
% i used inputs of circut as certificate but the order of calculation of gates is not clear(mentioned in Exercises 34.3-4)
% mabye it is a topological sort
\itm
کافیست به ترتیب مقدار خروجی گیت‌های منطقی حساب شود. از آنجا که اندازه ورودی را مجموع سیم‌ها و گیت‌ها تعریف کردیم و این الگوریتم چند جمله‌ایی است.
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{کلاس ان‌پی کامل}{مسئله ارضاء پذیری مدار}
\itm
فرض کنید L یک زبان دلخواه در ان‌پی باشد، می‌خواهیم ثابت کنیم هر زبان ان‌پی می‌تواند در زمان چند جمله‌ایی به زبان CIRCUIT-SAT کاهش یابد. فرض کنید تابع کاهش L به CIRCUIT-SAT را f بنامیم.
\itm
بنابراین تابع f هر ورودی x را به یک مدار منطقی ترکیبی C نگاشت می‌کند به نحوی که اگر x عضو L است C هم عضو CIRCUIT-SAT باشد و اگر x عضو L نیست C هم عضو CIRCUIT-SAT نباشد.
\itm
برای مثال فرض کنید می‌خواهیم زبان HAM-CYCLE به زبان CIRCUIT-SAT کاهش دهیم. اگر x را یک کد گذاری از گراف یک در نظر بگیریم تابع f آن را به یک مدار تبدیل می‌کند. این مدار ارضاء پذیر است اگر و تنها اگر گراف x دور همیلتونی داشته باشد.
\itm
بنابراین برای اثبات ان‌پی سخت بودن زبان CIRCUIT-SAT باید یک الگوریتم F با زمان چند جمله‌ایی ارائه دهیم که تابع کاهش f را محاسبه کند.
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{کلاس ان‌پی کامل}{مسئله ارضاء پذیری مدار}
%todo translation of verify should have mentioned before
\itm
از آنجا که L عضو ان‌پی است، باید الگوریتم A وجود داشته باشد که زبان L را در زمان چند جمله‌ایی «تایید» کند. الگوریتم F که در ادامه خواهیم ساخت، از الگوریتم A برای ساخت مدار استفاده می‌کند.
% M is ambiguous and book did not explain it more
\itm
ایده اصلی این است که محاسبات را به شکل دنباله‌ایی از پیکربندی‌ها در نظر بگیریم. اگر فرض کنیم مدار ترکیبی M سخت افزار کامپیوتر را شبیه سازی می‌کند، می‌تواند هر پیکربندی $c_i$ را به $ c_{i+1}$ نگاشت دهد.
\itm
فرض کنید T(n) زمان اجرای الگوریتم A  در بدترین حالت باشد. وظیقه F این است که مدار M را به تعداد T(n) کپی کند خروجی مدار iام که پیکربندی $c_i$ را تولید می‌کند مستقیماً به ورودی مدار i+1 ام وارد می‌شود.
\itm
در این پیاده سازی -برخلاف سخت افزار کامپیوتر- پیکربندی‌ها به جای اینکه در حافظه کامپیوتر ذخیره شوند، صرفاً به عنوان مقادیر روی سیم‌های متصل کننده کپی‌های M قرار می‌گیرند.
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{کلاس ان‌پی کامل}{مسئله ارضاء پذیری مدار}
\itm
زمانی که تابع F یک ورودی x دریافت می‌کند، ابتدا مقدار
 $n = |x|$
را محاسبه کرده و سپس یک مدار ترکیبی $C'$ می‌سازد که شامل $T(n)$ نسخه از ماشین $M$ است. (مقدار n برای محاسبه T(n) مورد نیاز است.)
\itm
ورودی مدار $C'$، یک پیکربندی اولیه است که متناظر با محاسبه‌ای روی $A(x, y)$ می‌باشد، و خروجی آن، روی یک بیت مشخص در آخرین پیکربندی قرار می‌گیرد ($c_{T(n)}$) .

\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{کلاس ان‌پی کامل}{مسئله ارضاء پذیری مدار}
\itm
در شکل زیر مداری که الگوریتم A را محاسبه می‌کند قابل مشاهده است:

\centerimg{figs/np-completeness/8.png}
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{کلاس ان‌پی کامل}{مسئله ارضاء پذیری مدار}
%need to explain computer cpu architecture
\itm
تا به اینجا الگوریتم A را با یک مدار پیاده سازی کردیم امّا A دو ورودی x و y دارد که باید مشخص شوند. ورودی x توسط مسئله داده شده است. الگوریتم F آن را مستقیماً متصل می‌کند. چندین ورودی دیگر مربوط به وظعیت‌های اولیه حافظه مانند شمارنده برنامه نیز هستند که مقدار آنها مشخص است.
\itm
بنابراین، تنها ورودی‌های باقی‌ماندهٔ مدار مربوط به گواه یعنی $y$ خواهد بود.
\itm
در مرحلهٔ دوم، الگوریتم تمام خروجی‌های مدار $C'$ را نادیده می‌گیرد، به جز یک بیت از آخرین پیکربندی که مربوط به خروجی برنامهٔ $A$ است.
\itm
بنابراین مدار $C$، برای هر ورودی $y$ ، مقدار $C(y)$ به این صورت محاسبه می‌کند:
$C(y) = A(x, y)$
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{کلاس ان‌پی کامل}{مسئله ارضاء پذیری مدار}
\itm
می‌خواهیم ثابت کنیم F یک الگوریتم کاهش چند جمله‌ایی است بنابراین باید دو ویژگی را اثبات کنیم.
%todo A(x, y) should have been defined foramlly

\itm
اول، باید نشان دهیم که الگوریتم $F$، به‌درستی یک تابع کاهش $f$ را محاسبه می‌کند.

یعنی باید نشان دهیم که مدار $C$ ارضاء‌پذیر است \textbf{اگر و تنها اگر} گواهی به نام $y$ وجود داشته باشد به‌طوری‌که
$A(x, y) = 1$.
\itm
دوم، باید نشان دهیم که الگوریتم $F$ در زمان چندجمله‌ای اجرا می‌شود.
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{کلاس ان‌پی کامل}{مسئله ارضاء پذیری مدار}
\itm
برای نشان دادن اینکه $F$ یک تابع کاهش را به‌درستی محاسبه می‌کند، ابتدا فرض کنید که گواهی‌ای به نام $y$ با طول وجود دارد به‌گونه‌ای که
$A(x, y) = 1$.
در این صورت، اگر بیت‌های $y$ را به‌عنوان ورودی به مدار $C$ اعمال کنیم، خروجی مدار برابر است با:
$$
C(y) = A(x, y) = 1
$$
پس اگر گواهی‌ای وجود داشته باشد، مدار $C$ ارضاء‌پذیر است.
\itm
در جهت عکس، فرض کنید که مدار $C$ ارضاءپذیر است. بنابراین، ورودی‌ای به نام $y$ برای $C$ وجود دارد که:

$C(y)=1$ .
و از این نتیجه می‌گیریم که:
$$A(x,y)=1$$
\itm
در نتیجه، الگوریتم $F$ تابع کاهش را به‌درستی محاسبه می‌کند.
\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{کلاس ان‌پی کامل}{مسئله ارضاء پذیری مدار}

\itm
حال باید ثابت کنیم F در زمان چند جمله‌ایی نسبت به
$n = |x|$
اجرا می‌شود.

%todo n^k should be defiend, T(n) = n^k should be mentioned before
\itm
مدار ترکیبی $M$ که سخت‌افزار رایانه را پیاده‌سازی می‌کند، اندازه‌ای چندجمله‌ای نسبت به اندازه یک پیکربندی دارد، ثابت می‌شود که اندازه پیکربندی
$O(n^k)$
است. بنابراین، اندازهٔ $M$ نیز نسبت به $n$ چندجمله‌ای خواهد بود.

%todo i did not understand this justification
\itm
مدار $C$ از
$O(n^k)$
نسخه از $M$ تشکیل شده است و در نتیجه، اندازهٔ آن نیز چندجمله‌ای در $n$ است.
بنابراین الگوریتم کاهش $F$ می‌تواند مدار $C$ را در زمان چندجمله‌ای بسازد.

\end{itemframe-s}

%----------------------------------------------------
\begin{itemframe-s}{کلاس ان‌پی کامل}{مسئله ارضاء پذیری مدار}
% should be mentioned that complexity classes are actually math sets
\itm
بنابراین، زبان $CIRCUIT-SAT$ حداقل به سختی هر زبان دیگری در $NP$ است، این یعنی این زبان در ان‌پی سخت است

\itm
به علاوه خود این زبان نیز در
$NP$
قرار دارد، پس ان‌پی‌-کامل است.

\end{itemframe-s}
