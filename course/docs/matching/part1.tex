\begin{itemframe}{مسیر افزایشی}
\itm
قبلا روشی بر پایه‌ی یافتن شار بیشینه برای یافتن تطابق بیشینه در گراف‌های دو‌بخشی را دیدیم.
\itm
این بخش یک روش کارآمدتر به نام الگوریتم هاپکرفت-کارپ
\fn{Hopcroft-Karp}
 ارائه می‌دهد که در زمان
 $O(\sqrt{|V|} \cdot |E|)$
 اجرا می‌شود.
\itm
برای این منظور ابتدا باید با مفهومی با نام مسیر افزایشی آشنا شویم.
\end{itemframe}


\begin{itemframe}{مسیر افزایشی}
\itm
یک تطابق حداکثری
\fn{maximal}
 تطابقی است که نتوان یال دیگری به آن افزود؛ یعنی برای هر یال $e \in E - M$، مجموعه‌ی $M \cup {e}$ یک تطابق نخواهد بود. یک تطابق بیشینه همواره حداکثری است، اما عکس آن لزوماً برقرار نیست.

\itm
بسیاری از الگوریتم‌ها برای یافتن تطابق بیشینه (از جمله الگوریتم هاپکرفت-کارپ) با افزایش تدریجی اندازه‌ی تطابق عمل می‌کنند.
\itm
فرض کنید تطابق $M$ در گراف بدون‌جهت $G = (V, E)$ داده شده باشد. یک «مسیر متناوب نسبت به $M$»
\fn{M-alternating path}
مسیری ساده است که یال‌های آن به صورت یکی در میان متعلق به $M$ و $E - M$ باشند.
\itm
یک «مسیر افزایشی نسبت به $M$»
\fn{M-augmenting path}
مسیر مسیر افزایشی نسبت به $M$، یک مسیر متناوب نسبت به $M$ است که یال‌های ابتدا و انتهای آن در $M$ نباشند.چنین مسیری همیشه دارای تعداد فردی از یال‌ها است.
\end{itemframe}


\begin{itemframe}{مسیر افزایشی}
\itm
در شکل زیر قسمت a یک تطابق با اندازه ۴ را در یک گراف دو بخشی بدون جهت نشان می‌دهد و قسمت b یک مسیر افزایشی نسبت به تطابق شکل قبل که دارای ۵ یال می‌باشد را به تصویر می‌کشد.
\centerimg[.4]{figs/matching/1.png}

\end{itemframe}


\begin{itemframe}{مسیر افزایشی}
\decLineSpace[1mm]
\itm
فرض کنید یک تطابق $M$ داشته باشیم و همچنین یک مسیر افزایشی $P$ نسبت به آن وجود داشته باشد. جالب است بندانید اگر یال‌های مشترک $P$ و $M$ را از $M$ حذف کنیم و بقیه یال‌های P را به M اضافه کنیم، نتیجه یک تطابق می‌شود که از M یک یال بیشتر دارد.
\itm
قسمت c شکل زیر همان تطابق قسمت a را نشان می‌دهد که مسیر افزایشی قسمت b روی آن اعمال شده.
\centerimg{figs/matching/2.png}

\end{itemframe}


\begin{itemframe}{مسیر افزایشی}

\itm
عملیات اعمال یک مسیر افزایشی به یک تطابق را می‌توان با عملگر تفاضل متقارن
\fn{symmetric difference}
 که یکی از عملگرهای تعریف شده بر روی مجوعه‌هاست، نشان داد.
\itm
تفاضل متقارن دو مجموعه به این صورت تعریف می‌شود؛
$$ X \oplus Y = X - Y \cup Y - X$$
یعنی عناصری که به X یا Y تعلق دارند، اما نه به هر دو.
\end{itemframe}


\begin{itemframe}{مسیر افزایشی}
\itm
پیش‌تر دیدیم که بعد از اعمال این عملیات
$M' = M \oplus P$
مجوعه $M' $ یک تطابق است که اندازه آن یک واحد از $M$ بیشتر است.
\itm
برای فهم بهتر این مسئله  فرض کنید مسیر افزایشی $P$ شامل ۳ یال باشد؛
$$ e_1=(v_1, v_2), e_2=(v_2, v_3), e_3(v_3, v_4)$$
می‌دانیم رأس‌های
$v_1$ و
$v_4$
تطابق‌نیافته هستند و بقیه‌ی رأس‌های آن تطابق‌یافته ‌اند.(در غیر این ‌صورت در تطابق $M$ بیش از یک یال به این رأس‌ها
متصل می‌شوند.)

\itm
در مسیر افزایشی یال اول و آخر در تطابق قرار ندارند بنابراین
$e_1$ و
$e_3$
در $M$ قرار ندارند، و یال
$e_2$
در $M$ قرار دارد.
\end{itemframe}


\begin{itemframe}{مسیر افزایشی}
\itm
تفاضل متقارن $M' = M \oplus P$، نقش یال‌ها را برعکس می‌کند؛ یال
$e_2$
را در از $M'$ حذف می‌کند و یال‌های
$e_1$ و
$e_3$
در $M'$ قرار می‌دهد.
\itm
با حذف یال
$e_2$
از $M$ رأس‌های
$v_2, v_3, v_1, v_4$
هیچ یال متصلی در $M'$  ندارند بنابراین با افزودن
$e_1$ و
$e_3$
مشکلی ایجاد نمی‌شود.
\itm
از میان سه یال
$e_1, e_2, e_3$
یک یال در $M$ و دو یال در $M'$ وجود دارد. بنابراین، تطابق $M'$ نسبت به $M$ یک یال بیشتر دارد و هیچ رأس یا یال دیگری در $G$ تحت تأثیر تغییر $M$ به $M'$ قرار نمی‌گیرد.
\itm
در نتیجه، $M'$ یک تطابق در $G$ است و
$$|M'| = |M| + 1$$

\end{itemframe}


\begin{itemframe}{مسیر افزایشی}
\itm
لم مهمی در بحث تطابق بیشینه وجود دارد که در آینده از آن در اثبات شرط خاتمه الگوریتم استفاده می‌کنیم.
\itm
فرض کنید
$M$ و
$M^*$
دو تطابق در گراف
$G = (V, E)$
 باشند، و گراف
$G' = (V, E')$
را در نظر بگیرید که یال‌های آن حاصل تفاضل متقارن این دو تطابق باشند. این لم بیان می‌کند که  اگر
$|M^*| > |M|$
باشد، آنگاه گراف $G'$ حداقل شامل $|M^*| - |M|$ مسیر متناوب نسبت به $M$ است که رأس‌های این مسیرها از یکدیگر مجزا اند.
\itm
\textbf{اثبات:}
هر رأس گراف $G'$ تنها می‌تواند درجه ۰ ، ۱ یا ۲ داشته باشد زیرا حداکثر یک یال متصل به هر رأس در یک تطابق وجود دارد. بنابراین اگر رأسی با درجه ۲ در  $G'$ وجود داشته باشد، قطعاً یکی از یال‌های متصل به آن متعلق به $M^*$ و دیگری متعلق به $M$ است.
%todo connected components should be discussed in appendix
\end{itemframe}


\begin{itemframe}{مسیر افزایشی}
\itm
حال بیایید رأس‌های این گراف را بررسی کنیم؛ رأس‌هایی که درجه ۰ دارند به هیچ جای دیگر از گراف متصل نیستند. رأس‌های با درجه ۱ و ۲ تنها می‌توانند یک مسیر ساده یا یک دور ساده را تشکیل دهند. همچنین این مسیرها و دور‌ها نمی‌توانند رأس مشترکی داشته باشند زیرا در غیر این صورت حداقل یک رأس باید از درجه ۳ یا بیشتر باشد.

\itm
همچنین دیدیم که هر رأس با درجه ۲ به یک یال از $M^*$ و یک یال از $M$ متصل است و در دور همه رأس‌ها از درجه ۲ هستند. پس دورهای گراف $G'$ نمی‌توانند تعداد فرد یال داشته باشند (چرا؟). همچنین نیمی از یال‌های هر دور به $M^*$ و نیمی دیگر به $M$ تعلق دارند.

\itm
به علاوه یال‌های هر مسیر هم به طور متناوب از دو تطابق است زیرا رأس‌های درونی یک مسیر نیز درجه ۲ هستند.

\end{itemframe}


\begin{itemframe}{مسیر افزایشی}
\itm
بنابراین، هر مؤلفه‌ی همبند در $G'$ یا یک رأس منفرد، یا یک دور ساده با طول زوج که یال‌های آن به‌صورت متناوب از $M$ و $M^*$ هستند، و یا یک مسیر ساده با یال‌های متناوب از $M$ و $M^*$ است.

\itm
فرض کردیم  $M^*$ از $M$ تعداد یال بیشتری داشته باشد.
پس مجموعه‌ی یال‌های $E'$ باید $|M^*| - |M|$ یال بیشتر از $M^*$ نسبت به $M$ داشته باشد (چرا؟).
\itm
دیدیم که تنها مؤلفه‌های همبندی موجود در $G'$ که دارای یال ‌هستند دور و مسیر هستند. پس تعداد یال‌های متعلق به $M^*$ باید در این مؤلفه‌ها بیشتر باشند. امّا در هر دور تعداد یال‌های برابری از هر دو تطابق استفاده شده. بنابراین، این مسیرهای ساده در $G'$ هستند که عامل این اختلاف در تعداد یال‌ها از $M^*$ نسبت به $M$ می‌باشند.

\end{itemframe}


\begin{itemframe}{مسیر افزایشی}
\itm
مسیرهایی که تعداد یال‌های برابری از هر تطابق داشته باشند نیز تأثیری ندارند. امّا مسیری که تعداد متفاوتی از یال‌های $M$ و $M^*$ را دارا باشد دو نوع دارد؛
\item[۱]
یا با یال‌هایی از $M$ شروع و پایان می‌یابد (و یک یال بیشتر از $M$ نسبت به $M^*$ دارد).
\item[۲]
یا با یال‌هایی از $M^*$ شروع و پایان می‌یابد (و یک یال بیشتر از $M^*$ نسبت به $M$ دارد).
\itm
از آن‌جایی که $E'$ شامل $|M^*| - |M|$ یال بیشتر از $M^*$ است، باید حداقل $|M^*| - |M|$ مسیر از نوع دوم وجود داشته باشد، توجه کنید این مسیرها تمام ویژگی‌های یک مسیر افزایشی نسبت به $M$ را دارند و دیدیم تمام این مسیرها از هم مجزا هستند. بنابراین لم بالا ثابت می‌شود.
\end{itemframe}



\begin{itemframe}{مسیر افزایشی}
\itm
حال اگر یک الگوریتم با افزودن تدریجی یال‌ها تطابق بیشینه را بیابد، چگونه تشخیص می‌دهد که باید متوقف شود؟ ثابت خواهیم کرد «زمانی که دیگر هیچ مسیر افزایشی وجود نداشته باشد» الگوریتم باید متوقف شود. به طور دقیق‌تر:
\itm
$M$ یک تطابق بیشینه است (p)
$\iff$
 هیچ مسیر افزایشی نسبت به $M$ در گراف وجود نداشته باشد (q)

%todo explain contrapositive in logics perhaps in appendix
\itm
\textbf{اثبات:}
باید ثابت کنیم
$(p \implies q) $
 (جهت اول) و
$ (q \implies p)$
 (جهت دوم) برقرار هستند. به جای این کار می‌توانیم عکس و نقیض
\fn{contrapositive}
 هر دو گزاره را اثباب کنیم.

\end{itemframe}


\begin{itemframe}{مسیر افزایشی}
\itm
عکس و نقیض جهت اول
($~q\implies~p$)
: اگر یک مسیر افزایشی نسبت به تطابقی وجود داشته باشد، آنگاه آن تطابق بیشینه نیست.
\itm
\textbf{اثبات جهت اول:}
اگر یک مسیر افزایشی نسبت به $M$، به نام $P$ وجود داشته باشد، آنگاه تطابق $M \oplus P$ یک یال بیشتر از $M$ دارد، بنابراین $M$ نمی‌تواند تطابق بیشینه باشد.

\itm
عکس و نقیض جهت دوم
($‍~p \implies ~q$)
: اگر تطابقی بیشینه نباشد، آنگاه حداقل یک مسیر افزایشی نسبت به آن در گراف وجود دارد.
\itm
\textbf{اثبات جهت دوم:}
اگر $M^*$ یک تطابق بیشینه باشد به‌طوری که $|M^*| > |M|$. آنگاه طبق لم قبلی، گراف $G$ حداقل شامل
$|M^*| - |M| > 0$
 مسیر افزایشی با رأس‌های مجزا نسبت به $M$ است.
\end{itemframe}


\begin{itemframe}{‌معرفی الگوریتم هاپکرفت-کارپ}
\itm
تا به اینجا می‌توانیم الگوریتمی برای یافتن یک تطابق بیشینه طراحی کنیم که در زمان $O(VE)$ اجرا می‌شود.
\itm
به این صورت که با یک تطابق تهی $M$ آغاز می‌کنیم. سپس به‌صورت تکراری، یکی از گونه‌های جست‌وجوی اول سطح یا جست‌وجوی اول عمق را از یک رأس تطابق‌نیافته آغاز می‌کنیم تا مسیری متناوب بیابیم که به یک رأس دیگر که تطابق‌نیافته است ختم شود.
\itm
از مسیر افزایشی حاصل‌شده برای افزودن یک یال به $M$ استفاده می‌کنیم، تا اندازه‌ی آن یک واحد افزایش یابد.
\itm
امّا هاپکرفت-کارپ زمان اجرای بهتری از این الگوریتم اولیه‌ایی ارائه می‌دهد.برای معرفی این الگوریتم ابتدا باید با لم دیگری که در این الگوریتم به کار می‌رود آشنا شویم.
\end{itemframe}


\begin{itemframe}{‌معرفی الگوریتم هاپکرفت-کارپ}
\itm
ثابت می‌شود که اگر k مسیر افزایشی مجزا داشته باشیم (رأس‌های مشترک نداشته باشند) می‌توان آنها را اجتماع گرفت و نیجه را با تطابق تفاضل متقارن گرفت. در این صورت اندازه تطابق k واحد افزایش می‌یابد:
$$M' = M \oplus (P_1 \cup P_2 \cup \cdots \cup P_k)$$
\itm
برای اثباب این ادعا باید استدلال کنید که مجزا بودن مسیرها باعث می‌شود:
$$P_1 \cup P_2 \cup \cdots \cup P_k = P_1 \oplus P_2 \oplus \cdots \oplus P_k$$
سپس با استفاده از استقرا روی $i$، می‌توان نشان داد که تطابق
$$M' = M \oplus (P_1 \cup P_2 \cup \cdots \cup P_{i-1})$$
دارای $|M| + (i - 1)$ یال است، و مسیر $P_i$ یک مسیر افزایشی نسبت به این تطابق جدید است.
\end{itemframe}


\begin{itemframe}{‌معرفی الگوریتم هاپکرفت-کارپ}
\itm
الگوریتم هاپکرفت-کارپ زمان اجرا را به $O(\sqrt{V E})$ بهبود می‌بخشد. روال \texttt{HOPCROFT-KARP} یک گراف دوبخشی بدون جهت را دریافت می‌کند و مکرراً اندازه‌ی تطابق را افزایش می‌دهد.
\begin{algorithm}[H]\alglr
\caption{HOPCROFT-KARP}
\begin{algorithmic}[1]
	\State $M \gets \emptyset$
	\Repeat
        \State let $P = \{P_1, P_2, \ldots, P_k\}$ be a maximal set of vertex-disjoint shortest $M$-augmenting paths
		\State $M \gets M \oplus (P_1 \cup P_2 \cup \ldots \cup P_k)$
	\Until{$P = \emptyset$}
	\State \Return $M$
\end{algorithmic}
\end{algorithm}
\end{itemframe}


\begin{itemframe}{‌معرفی الگوریتم هاپکرفت-کارپ}
\itm
امًا چطور زمان اجرای الگوریتم برابر با $O(\sqrt{V E})$ است؟

خواهیم دید که حلقه‌ی \texttt{repeat} در خطوط ۲ تا ۵، تعداد $O(\sqrt{V})$ بار تکرار می‌شود و اینکه چگونه خط ۳ را می‌توان به‌گونه‌ای پیاده‌سازی کرد که در هر تکرار، در زمان $O(E)$ اجرا شود.
\itm
بیایید ابتدا ببینیم چگونه می‌توان یک مجموعه‌ی حداکثری از مسیرهای افزایشی مجزا نسبت به $M$ که اندازه آنها برابر با کوتاه‌ترین مسیر افزایشی موجود است، را در زمان $O(E)$ پیدا کرد. این کار در سه مرحله انجام می‌شود:

\end{itemframe}


\begin{itemframe}{‌معرفی الگوریتم هاپکرفت-کارپ}
\itm
\textbf{مرحله‌ی اول}،
یک نسخه‌ی جهت‌دار از گراف دوبخشی بدون جهت $G$ با نام $G_M$ ایجاد می‌کند.
\itm
\textbf{مرحله‌ی دوم}،
از طریق گونه‌ای از جست‌وجوی اول عرض، یک گراف جهت‌دار بی‌دور با نام $H$ از $G_M$ می‌سازد.
\itm
\textbf{مرحله‌ی سوم}،
با اجرای گونه‌ای از جست‌وجوی اول عمق بر روی گراف معکوس‌شده‌ی $H$، که آن را $H^T$ می‌نامیم، یک مجموعه‌ی بیشینه از کوتاه‌ترین مسیرهای افزایشی مجزا می‌یابد.
\itm
در گراف معکوس‌شده‌ی یک گراف جهت‌دار، جهت هر یال وارونه می‌شود. از آنجا که $H$ بی‌دور است، $H^T$ نیز بی‌دور خواهد بود.
\end{itemframe}


\begin{itemframe}{‌معرفی الگوریتم هاپکرفت-کارپ}
%todo ask what about pathes starting from R?
\itm
فرض کنید یک مسیر افزایشی نسبت به تطابقی مانند M از یک رأس تطابق نیافته در L آغاز می‌شود.
\itm
در این صورت یال‌های این مسیر که از L به R می‌روند، متعلق به مجموعه M نیستند، و یال‌های مسیر که از R به L می‌روند، در تطابق M قرار دارند. (به دلیل ویژگی تناوب یال‌های مسیر افزایشی می‌توان چنین نتیجه گرفت)
\itm
بنابراین، \textbf{مرحله اول} گراف جهت‌داری به نام
$G_M = (V, E_M)$
را ایجاد می‌کند که یال‌های آن مطابق با توضیحات فوق جهت‌دهی شده‌اند:
$$
E_M = \{ (l, r) \mid l \in L,\, r \in R,\, (l, r) \in E - M \} \cup \{ (r, l) \mid r \in R,\, l \in L,\, (l, r) \in M \}
$$

%todo this explanation is wrong
\itm
به زبان ساده، در گراف جدید یال‌های از L به R در تطابق نیستند و یال‌های از R به L در تطابق قرار دارند.
\end{itemframe}


\begin{itemframe}{‌معرفی الگوریتم هاپکرفت-کارپ}
\itm
شکل سمت چپ یک گراف دو بخشی بدون جهت G و یک تطابق M بر روی آن را نشان می‌دهد و شکل سمت راست گراف جهت دار $G_M$ را نشان می‌دهد.
\begin{figure}[h]
  \centering
  \begin{minipage}{0.45\textwidth}
	\centerimg[.4]{figs/matching/4.png}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
	\centerimg[.4]{figs/matching/3.png}
  \end{minipage}
\end{figure}

\end{itemframe}


\begin{itemframe}{‌معرفی الگوریتم هاپکرفت-کارپ}
\decLineSpace[-1mm]
\itm
در مرحله اول گراف $G_M$ ایجاد شد. در \textbf{مرحلهٔ دوم} یک جهت‌دار بدون دور (DAG) ایجاد می‌شود $H = (V_H, E_H)$ که ، دارای چند لایه‌ رأس است.
\centerimg[.4]{figs/matching/5.png}
\itm
شکل b گراف H را نشان می‌دهد که متناظر با گراف جهت‌دار $G_M$ در شکل b است. هر لایه فقط شامل رأس‌هایی از مجموعه $L$ یا فقط از مجموعه $R$ است و لایه‌ها به صورت متناوب از $L$ و $R$ تشکیل می‌شوند.
\end{itemframe}


\begin{itemframe}{‌معرفی الگوریتم هاپکرفت-کارپ}
\itm
رأسی مثل v را در نظر بگیرید. فرض کنید در گراف $G_M$ کمترین فاصله‌ایی که یک رأس تطابق نیافته در مجموعه L با v دارد ۳ باشد. آنگاه ٰرأس v در لایه سوم از H‌ قرار می‌‌گیرد. این فاصله را با d نشان می‌دهیم و فرض می‌کنیم هر رأس یک مقدار d دارد.
\itm
بنابراین با کمی بررسی در می‌یابید که رأس‌های متعلق به L در لایه‌های زوج ظاهر، و رأس‌های متعلق به R در لایه‌های فرد ضاهر خواهند شد.
\itm
امّا همه رأس‌ها در H ضاهر نمی‌شوند. درواقع تنها رأس‌هایی که مقدار d آن‌ها کمتر یا مساوی مقدار q باشد وارد H می‌شوند. پس آخرین لایه در H شامل رأس‌هایی از R با مقدارد d برابر q خواهد بود.
\itm
مقدار q که در گراف $G_M$ تعریف می‌شود برابر است با: کمترین مقدار d در بین رئوس تطابق نیافته مجموعه R.

\end{itemframe}


\begin{itemframe}{‌معرفی الگوریتم هاپکرفت-کارپ}
\itm
یال‌های موجود در $E_H$ زیرمجموعه‌ای از $E_M$ هستند و به‌صورت زیر تعریف می‌شوند:
$$
E_H = \{ (l, r) \in E_M \mid r.d \leq q \ \text{and} \ r.d = l.d + 1 \} \cup \{ (r, l) \in E_M \mid l.d \leq q \}
$$

%todo ask how exactly bfs works here?
\itm
برای تعیین مقدار d همه رأس‌ها، باید نوعی پیمایش اول سطحی را روی $G_M$ اجرا کرد، با این تفاوت که شروع BFS نه از یک رأس، بلکه از تمام رأس‌های بدون تطابق در L انجام می‌گیرد.(توجه کنید که این کار با چند بار اجرای BFS متفاوت است.)
\itm
هر مسیر در H که از یک رأس در لایهٔ ۰ به یک رأس تطابق نیافته در لایهٔ q منتهی شود، متناظر با یک مسیر افزایشی در گراف اصلی است و اندازه همه این مسیرها برابر با کوتاه‌ترین مسیر افزایشی موجود در گراف است. کافی است نسخهٔ بدون جهت از یال‌های جهت‌دار در H را استفاده کرد.

\itm
علاوه بر این، همه کوتاه‌ترین مسیرهای افزایشی نسبت به M در H وجود دارند.
\end{itemframe}


\begin{itemframe}{‌معرفی الگوریتم هاپکرفت-کارپ}
\itm
\textbf{مرحلهٔ سوم}
یک مجموعهٔ حداکثری از کوتاه‌ترین مسیرهای افزایشی مجزا نسبت به $M$ را می‌یابد.
این مرحله با ایجاد ترانهادهٔ گراف H آغاز می‌شود. در شکل زیر $H^T$ نمایش داده شده است .
\centerimg{figs/matching/6.png}
\end{itemframe}


\begin{itemframe}{‌معرفی الگوریتم هاپکرفت-کارپ}
\decLineSpace[1mm]
\itm
پس از تشکیل  $H^T$ از هر رأس تطابق نیافته در لایهٔ q نوعی از جستجوی اول عمق اجرا می‌شود و با هربار انجام جستجو حداکثر یک مسیر یافت می‌شود.
\itm
%todo ask does this need more explanation?
%todo mabye the discussion about discovery, finish time and dfs search tree and predecessor pointer should be in appendix
در این جستجو باید از اشاره‌گر پدر استفاده کرد. یه این صورت که پس از رسیدن به یک رأس در لایهٔ ۰، با دنبال‌کردن ‌اشاره‌گرهای پدر، یک مسیر افزایشی یافت می‌شود.

\itm
این جستجو در دو حالت متوقف می‌شود:
الف) تمام مسیرهای ممکن را بدون رسیدن به لایهٔ ۰ بررسی کرده باشد.
ب) به یک رأس کاوش نشده در لایهٔ ۰ برسد. (اگر این جمله نامفهوم است به ادامه توضیحات توجه کنید)،

\itm
در جستجوی اول عمق استاندارد تا زمانی که الگوریتم به بن‌بست نخورده جستجو ادامه می‌یابد. امّا توجه کنید در اینجا پس از رسیدن به یک رأس در لایه ۰ جستجو متوقف می‌شود. بنابراین معمولاً تعداد زیادی از رئوس کاوش نشده باقی می‌ماند.
\itm
در جستجوی اول عمق استاندارد رئوس تنها می‌توانند یکبار کاوش شوند. در اینجا یک تفاوت اساسی وجود دارد: هر رأس در \textbf{تمامی} جستجوهای انجام شده تنها یک بار می‌تواند کاوش شود.
%todo there is an extra explanation about dfs that i did not get it
\end{itemframe}


\begin{itemframe}{‌معرفی الگوریتم هاپکرفت-کارپ}
\itm
برای درک بهتر این نسخه از جستوی اول عمق بار دیگر به شکل زیر دقت کنید:
\centerimg[.3]{figs/matching/6.png}
%todo this part need a refer to discover concept in dfs
\itm
اولین جستجو از رأس
$r_1$
آغاز می‌شود و مسیر
$$ (r_1, l_3), (l_3, r_3), (r_3, l_1) $$
را می‌یابد که با رنگ نارنجی مشخص شده. و رئوس
$r_1, l_3, r_3, l_1$
را در حالت کاوش شده قرار می‌دهد.
\end{itemframe}


\begin{itemframe}{‌معرفی الگوریتم هاپکرفت-کارپ}
\itm
 جستجو بعدی از رأس
$r_4$
شروع می‌شود که ابتدا یال
$(r_4, l_3)$
را بررسی می‌کند. امّا
$l_4$
در جستجوی قبلی کاوش شده. این جستجو در نهایت مسیر
$$(r_4, l_5), (l_5, r_7), (r_7, l_6)$$
را می‌یابد که با زرد مشخص شده است. و رئوس
$r_4, l_5, r_7, l_6$
را کاوش می‌کند.
\itm
سپس جستجو از رأس
$r_6$
آغاز می‌شود که به رئوس
$l3, l5$
برمی‌خورد که از قبل کاوش شده اند و بنابراین این جستجو همینجا متوقف می‌شود.
\end{itemframe}


\begin{itemframe}{‌معرفی الگوریتم هاپکرفت-کارپ}
\itm
نتیجه اجرای این الگوریتم یک مجموعه حداکثری شامل دو کوتاه‌ترین مسیر‌ افرایشی مجزا می‌باشد:

$$
\{(r_1, l_3), (l_3, r_3), (r_3, l_1) \text{ و } (r_4, l_5), (l_5, r_7), (r_7, l_6) \}
$$

توجه کنید که طول همه این مسیر‌ها و یکسان و برابر با طول کوتاه‌ترین مسیر افزایشی گراف اصلی هستند.

\itm
در اینجا می‌توانیم حداکثری بودن این مجموعه را بهتر درک کنیم. به مجموعه بالا هیچ مسیر افزایشی دیگری نمی‌توان افزود به گونه‌ایی که با مسیرهای فعلی رأس مشترک نداشته باشد بنابراین این مجموعه حداکثری است. امّا بیشینه نیست زیرا مجموعه زیر وجود دارد که دارای سه کوتاه‌ترین مسیر افزایشی مجزا است:
$$
(r_1, l_2) ,(l_2, r_2), (r_2, l_1), \text{ و } (r_4, l_3), (l_3, r_3), (r_3, l_4), \text{ و } (r_6, l_5),  (l_5, r_7),  (r_7, l_6)
$$

\itm
امّا الگوریتم هاپکرفت-کارپ الزامی به یافتن مجموعه بیشینه ندارد و یافتن مجموعه حداکثری کفایت می‌کند.

\end{itemframe}


\begin{itemframe}{‌پیچیدگی زمانی هاپکرفت-کارپ}
\itm
بررسی نحوه کار الگوریتم هاپکرفت-کارپ به اتمام رسید. در ادامه به بررسی پیچیدگی زمانی این الگوریتم می‌پردازیم.
\itm
ابتدا می‌خواهیم ثابت کنیم هر سه مرحله یافتن مسیرهای افزایشی در زمان $O(E)$ انجام می‌شود. پیش از این فرض کردیم که در گراف دو بخشی هر رأس حداقل به یک یال متصل است پس
$|V| = O(V)$
و درنتیجه
$$|V| + |E| = O(E)$$

\itm
مرحله اول گراف
$G_M$
را صرفاً با جهت دادن به یال‌های گراف اصلی می‌سازد. تعداد یال‌ها و رأس‌های آن با گراف اصلی برابر است. هر رأس حداکثر یک بار پیمایش می‌شود پس این مرحله از مرتبه $O(E)$ است.
\end{itemframe}


\begin{itemframe}{‌پیچیدگی زمانی هاپکرفت-کارپ}
\itm
مرحله دوم یک جستجوی اول سطح روی
$G_M$
انجام می‌دهد. مرتبه جستجوی اول سطح
$O(V_M+E_M)$
است که برابر است با:
$$O(V_M+E_M) = O(E_M) = O(E)$$

\itm
ساختن گراف H از مرتبه
$O(V_H)$
زمان می‌برد. رئوس و یال‌ها در این گراف زیر مجموعه‌ایی از گراف $G_M$ هستند بنابراین
$$O(V_H+E_H) = O(E)$$
\itm
بنابراین دیدم که اجرای این سه مرحله از مرتبه زمانی
$O(E)$
است.
\end{itemframe}


\begin{itemframe}{‌پیچیدگی زمانی هاپکرفت-کارپ}
\itm
بار دیگر به شبه کد الگوریتم هاپکرفت-کارپ دقت کنید؛ دیدیم که خط ۳ در زمان $O(E)$ اجرا می‌شود. بروزرسانی تطابق در خط ۴ هم در  زمان $O(E)$ انجام می‌شود. کافیست یک بار روی همه یال‌های مسیرهای افزایشی پیمایش انجام داد و هر کدام را از تطابق حذف کرد یا به آن اضافه کرد.
\itm
بنابراین هر دور از حلقه در زمان $O(E)$ انجام می‌شود امّا این حلقه چند بار اجرا می‌شود؟ خواهیم دید که دفعات اجرای این حلقه از مرتبه
$O(\sqrt{|V|})$
است.
\itm
برای اثبات پیچیدگی زمانی مطرح شده باید ابتدا لمی را ثابت کنیم که بیان می‌کند پس از هر تکرار حلقه، طول کوتاه‌ترین مسیر افزایشی زیاد می‌شود.
\end{itemframe}


\begin{itemframe}{‌پیچیدگی زمانی هاپکرفت-کارپ}
\itm
فرض $S$ یک مجموعهٔ ماکسمال از کوتاه‌ترین مسیرهای افزایشی با طول $q$ باشد که توسط الگوریتم یافت شده.
اعمال مسیرهای افزایشی تطابق $M'$ را به این صورت تشکیل می‌دهد:
$$
M' = M \oplus (P_1 \cup P_2 \cup \dots \cup P_k)
$$
\itm
فرض کنید $P$ یک کوتاه‌ترین مسیر افزایشی نسبت به $M'$ باشد. در این صورت، می‌خواهیم ثابت کنیم طول $P$ بیشتر از $q$ است.
\itm
\textbf{اثبات}:
 دو حالت ممکن را جداگانه بررسی می‌کنیم:
 ۱) حالتی که $P$ از مسیرهای موجود در $S$ مجزا باشد ،
 ۲) حالتی که $P$ حداقل با یکی از آن‌ها رأس مشترک داشته باشد.
\end{itemframe}


\begin{itemframe}{‌پیچیدگی زمانی هاپکرفت-کارپ}
\itm
در \textbf{حالت اول}  $P$ شامل یال‌هایی از $M$ است که در هیچ‌یک از مسیرهای $P_1, P_2, \dots, P_k$ وجود ندارند؛ پس یال‌های این مسیر پس از اعمال تغییرات دست نخورده باقی می‌مانند. بنابراین، $P$ یک مسیر افزایشی نسبت به $M$ نیز هست.
\itm
 مسیر $P$ از مسیرهای $P_1, \dots, P_k$ مجزا است ولی خود یک مسیر افزایشی نسبت به $M$ است. از آنجا که $P$ یک مجموعهٔ حداکثری است، نتیجه می‌گیریم طول $P$ بیش از $q$ است و به همین دلیل نتوانسته عضو $S$ شود.
\end{itemframe}


\begin{itemframe}{‌پیچیدگی زمانی هاپکرفت-کارپ}
\itm
در \textbf{حالت دوم} فرض می‌کنیم $P$ حداقل با یکی از مسیرهای افزایشی در $S$ رأس مشترک داشته باشد.
\itm
در روند اثبات از یک متغییر کمکی A استفاده می‌کنیم که به این‌صورت تعریف می‌شود:
$$
A = M \oplus M' \oplus P
$$
A
 مجموعه‌ایی از یال‌ها می‌باشد.
\itm
همچنین به دلیل طولانی بودن اثبات حالت دوم، آن را به سه بخش تقسیم می‌کنیم تا فهم آن ساده‌تر شود.
\end{itemframe}


\begin{itemframe}{‌پیچیدگی زمانی هاپکرفت-کارپ}
\itm
در \textbf{بخش اول} می‌خواهیم یک حد پایین برای اندازه مجموعه A بیابیم.
\itm
می‌دانیم که $M' \oplus P$ خود یک تطابق است که آن را $M^*$ می‌نامیم. حال بار دیگر به تعریف A دقت کنید؛
$$
A = M \oplus M' \oplus P = M \oplus M^*
$$
\itm
پیش‌تر ثابت کردیم تفاضل متقارن دو تطابق، مجموعه‌ایی از مسیر‌های افزایشی مجزا را نتیجه می‌دهد که تعداد آنها برابر با تفاضل انداز تطابق‌هاست. بنابراین $A$ شامل حداقل $|M^*| - |M|$ مسیر افزایشی است.
\itm
 حال بیایید اندازه $M^*$ را محاسبه کنیم:
$$
|M^*| =  |M' \oplus P| = |M'| + 1 = |M \oplus (P_1 \cup P_2 \cup \dots \cup P_k)| + 1= |M| + k + 1
$$
\end{itemframe}


\begin{itemframe}{‌پیچیدگی زمانی هاپکرفت-کارپ}
\itm
بنابراین تعداد مسیرهای مجزای موجود در A برابر است با:
$$
|M^*| - |M| = (|M| + k + 1) - (|M|) = k + 1
$$

\itm
مجموعه A شامل یال‌های
$k + 1$
مسیر مجزاست که هر کدام حداقل $q$ یال دارد، نتیجه می‌گیریم:
$$
(k + 1)q \leq |A|
$$
بنابراین:
$$
kq + q \leq |A|
$$
\end{itemframe}


\begin{itemframe}{‌پیچیدگی زمانی هاپکرفت-کارپ}
\itm
در \textbf{بخش دوم } می‌خواهیم ثابت کنیم که $P$ با حداقل یکی از مسیرهای $S$ یال مشترک دارد.
\itm
می‌دانیم در هر مسیر افزایشی نسبت به $M$ همه رئوس به غیر از رأس اول و آخر، تحت $M$ تطابق‌یافته اند ولی با اعمال
$M \oplus P_i$
 تمام رأس‌های $P_i$ از جمله رأس اول و آخر تطابق‌یافته می‌شوند.
\itm
 از آنجا که مسیرها مجزا هستند مسیرهای دیگری که بر تطابق اعمال می‌شوند نمی‌توانند وضعیت تطابق‌یافته بودن رئوس $P_i$ را تحت تأثیر قرار دهند.
\itm
 بنابراین تحت تطابق $M'$، تمام رأس‌های موجود در همه مسیرهای مجموعه $S$ تطابق‌یافته هستند.
\end{itemframe}


\begin{itemframe}{‌پیچیدگی زمانی هاپکرفت-کارپ}
\itm
 حال فرض کنید که مسیر $P$ با مسیر $P_i \in S$ یک رأس مشترک $v$ داشته باشد. دیدم که همه رئوس مسیر $P_i$ در نسبت به $M'$‌ تطابق‌یافته هستند. پس $v$ هم تطابق یافته است.
\itm
بنابراین $v$ نمی‌تواند یکی از دو سر انتهایی مسیر $P$ باشد، زیرا این دو رأس در $M'$ تطابق‌نیافته هستند.

پس رأس $v$ یکی از رئوس میانی $P$ است و به دلیل ویژگی تناوب یال‌ها در مسیر افزایشی، $v$ باید به یالی مانند
$e_1$
عضو $M'$ متصل باشد به طور دقیق‌تر:
$$e_1 \in M' \text{ and } e_1 \in P$$

\end{itemframe}


\begin{itemframe}{‌پیچیدگی زمانی هاپکرفت-کارپ}
% this part is added by myself no expalnation about this is in clrs.
\decLineSpace
\itm
رأس $v$ می‌تواند در انتها یا در میانه مسیر $P_i$ باشد.
\item[الف]
اگر $v$ در میانه مسیر باشد: یالی که در $P_i$ عضو  $M$ باشد عضو $M'$ نیست و بلعکس. پس ویژگی تناوب این مسیر نسبت به $M'$ هم برقرار است یعنی یال‌های $P_i$ به طور متناوب عضو $M'$ هستند. پس یکی از یال‌های متصل به $v$ عضو $M'$ است.
\item[ب]
اگر $v$ در یکی از دو انتهای مسیر باشد: $P_i$ مسیر افزایشی نسبت به $M$ است. پس دو یال انتهایی آن که عضو $M$ نبودند حال عضو $M'$ هستند. پس یکی از یال‌های متصل به $v$ عضو $M'$ است.\\
\itm
نتیجه می‌گیریم $v$ باید به یالی مانند
$e_2$
 متصل باشد به طوری که:
$$e_2 \in M' \text{ and } e_2 \in P_i$$


\itm
هر رأس حداکثر به یک یال از یک تطابق متصل است، بنابراین
$e_1$
و
$e_2$
نمی‌توانند دو یال متفاوت باشند. پس ثابت می‌شود $P$ با حداقل یکی از مسیرهای $S$ یال مشترک دارد.
\end{itemframe}


\begin{itemframe}{‌پیچیدگی زمانی هاپکرفت-کارپ}
\itm
در \textbf{بخش سوم} می‌خواهیم نشان دهیم:
$$
A = (P_1 \cup P_2 \cup \dots \cup P_k) \oplus P
$$
\itm
داریم:
\begin{align*}
A &= M \oplus M' \oplus P \\
& = M \oplus (M \oplus (P_1 \cup P_2 \cup \dots \cup P_k)) \oplus P \\
&= (M \oplus M) \oplus (P_1 \cup \dots \cup P_k) \oplus P \quad
\text{(با توجه به شرکت پذیری $\oplus$)} \\
&= \emptyset \oplus (P_1 \cup \dots \cup P_k) \oplus P \quad
\text{(چون $X \oplus X = \emptyset$ برای هر $X$)} \\
&= (P_1 \cup \dots \cup P_k) \oplus P \quad
\text{(چون $\emptyset \oplus X = X$)}
\end{align*}

\end{itemframe}


\begin{itemframe}{‌پیچیدگی زمانی هاپکرفت-کارپ}
\itm
دیدم که A برابر است با
$
(P_1 \cup \dots \cup P_k) \oplus P
$
و چون مسیر $P$ با حداقل یکی از مسیرهای $P_i \in P$ یال مشترک دارد، بنابراین خواهیم داشت:
$$
|A| < |P_1 \cup P_2 \cup \dots \cup P_k| + |P|
$$
از طرف دیگر:
\begin{align*}
kq+q & ≤∣A∣\\
& < |P_1 \cup P_2 \cup \dots \cup P_k| + |P|\\
& = kq + |P|
\end{align*}

\end{itemframe}


\begin{itemframe}{‌پیچیدگی زمانی هاپکرفت-کارپ}
\itm
دریافتیم که رابطه زیر برقرار است:
$$
kq+q  < kq + |P|
$$
\itm
حال به خط زدن $kq$ از طرفین نتیجه می‌شود
$q < |P|$
و اثبات کامل می‌شود. پس ثابت کردیم اندازه کوتاه‌ترین مسیرهای افزایشی پس از هر تکرار از هاپکرفت-کارپ افزایش می‌یابد.
\itm
برای اثبات پیچیدگی زمانی هاپکرفت-کارپ باید یک لم دیگر را نیز بررسی کنیم. این لم یک حد بالا برای اندازه تطابق مشخص می‌کند.
\end{itemframe}


\begin{itemframe}{‌پیچیدگی زمانی هاپکرفت-کارپ}
\decLineSpace[0mm]
\itm
فرض کنید طول کوتاه‌ترین مسیر افزایشی نسبت به تطابق $M$ در گراف $G = (V, E)$ برابر با $q$ باشد. می‌خواهیم ثابت کنیم اندازهٔ یک تطابق بیشینه در $G$ حداکثر برابر است با:
$$∣M∣+ \frac{ |V|}{q + 1}$$

\itm
\textbf{اثبات:}
فرض کنید $M^*$ یک تطابق بیشینه باشد. گراف $G$ شامل حداقل $|M^*| - |M|$ مسیر افزایشی مجزا نسبت به $M$ است.
هر یک از این مسیرها حداقل شامل $q$ یال است، و در نتیجه حداقل
$q + 1$
رأس دارد.
\itm
از آن‌جا که این مسیرها مجزا هستند، داریم:
$$(∣M∗∣−∣M∣)(q+1) \leq |V|$$
و بنابراین:
$$∣M∗∣ \leq∣M∣ + \frac{|V|}{q + 1}$$
%todo ask this upper bound is nerver used
\end{itemframe}


\begin{itemframe}{‌پیچیدگی زمانی هاپکرفت-کارپ}
\itm
حال می‌توانیم نشان دهیم شبه کد الگوریتم HOPCROFT-KARP، حلقهٔ خطوط ۲ تا ۵ از مربته $O(\sqrt{|V|})$ بار تکرار می‌شود.

\itm
\textbf{اثبات:}
طول کوتاه‌ترین مسیرهای افزایشی که در خط ۳ پیدا می‌شوند، در هر تکرار افزایش می‌یابد. بنابراین، پس از
$\sqrt{\lceil |V| \rceil}$
تکرار، خواهیم داشت:
$$\sqrt{\lceil |V| \rceil} \leq q$$
\end{itemframe}


\begin{itemframe}{‌پیچیدگی زمانی هاپکرفت-کارپ}
\itm
حال، شرایط را پس از اولین باری بررسی می‌کنیم که خط ۴ اجرا می‌شود و مسیرهای افزایشی با طول حداقل
$\sqrt{\lceil |V| \rceil}$
 را اعمال می‌کند.
\itm
در هر تکرار، اندازهٔ تطابق حداقل به‌اندازهٔ یک یال افزایش می‌یابد. در بدترین حالت هر تکرار تنها یک واحد به اندازه تطابق اضافه می‌کند. پس حداکثر تعداد تکرارهای باقی‌مانده برای رسیدن به یک تطابق بیشینه برابر است با:
$$
∣M^∗∣−∣M∣
$$
\itm
دیدیم که این مقدار برابر است با:
$$
\frac{ |V|}{q + 1} = \frac{|V|}{\sqrt{|V|} + 1} < \frac{|V|}{\sqrt{|V|}} = \sqrt{|V|}
$$

\end{itemframe}


\begin{itemframe}{‌پیچیدگی زمانی هاپکرفت-کارپ}
\itm
بنابراین، تعداد کل تکرارهای حلقه کمتر از $2\sqrt{|V|}$ است. پس مرتبه اجرای الگوریتم برابر است با:
$$
O(2\sqrt{|V|} E) = O(\sqrt{|V|} E)
$$
\end{itemframe}
