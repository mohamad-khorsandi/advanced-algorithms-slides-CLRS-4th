\begin{itemframe}{الگوریتم مجارستانی}
\itm
بیایید بار دیگر اطلاعاتی را به یک گراف دو بخشی \textbf{کامل} اضافه کنیم است.
این بار به هر یال یک وزن اختصاص می‌دهیم.
دوباره فرض می‌کنیم مجموعه‌های $L$ و $R$ هر یک شامل $n$ رأس هستند، بنابراین گراف دارای
$n^2$
یال خواهد بود.
\itm
برای $l \in L$ و $r \in R$، وزن یال $(l, r)$ را با $w(l, r)$ نمایش می‌دهیم که نشان‌دهنده‌ی میزان سودی است که از تطبیق رأس $l$ با رأس $r$ به دست می‌آید.
\itm
یک تطابق کامل
\fn{perfect matching}
 تطابقی است که تحت آن همه رأس‌ها تطابق‌یافته باشند.

\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
در این مسئله هدف یافتن یک تطابق کامل مانند
$M^*$
 است به‌طوری‌که مجموع وزن یال‌های آن، در میان همه تطابق‌های کامل، بیشینه باشد.
به این مسئله،‌ مسئله تخصیص
\fn{assignment problem}
 گفته می‌شود.
\itm
بررسی تمام تطابق‌های کامل از مرتبه
$ \Omega (n!)$
است. اما الگوریتمی به نام الگوریتم مجارستانی
\fn{Hungarian algorithm}
 این مسئله را بسیار سریع‌تر حل می‌کند.
\itm
این الگوریتم ا زمرتبه زمانی
$O(n^4)$
 است.
(البته می‌توان زمان اجرای آن را به
$O(n^3)$
 کاهش داد.)
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
الگوریتم مجارستانی به جای کار با گراف دوبخشی کامل $G$، با زیرگرافی از آن به نام زیرگراف تساوی
\fn{equality subgraph}
کار می‌کند.
این زیرگراف به‌صورت پویا تغییر می‌کند و هر تطابق کامل در زیرگراف تساوی، یک راه‌حل بهینه برای مسئله تخصیص نیز هست.
\itm
زیرگراف تساوی با تخصیص یک عدد به هر رأس ساخته می‌شود. به این عدد برچسب رأس گفته می‌شود و با h نشان داده می‌شود.
\itm
می‌گوییم $h$ یک برچسب‌گذاری مجاز
\fn{feasible labeling}
است اگر برای همه $l \in L$ و $r \in R$ رابطه زیر برقرار باشد:
$$l.h + r.h \geq w(l, r)$$
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
یک برچسب‌گذاری مجاز همواره وجود دارد. به عنوان مثال، می‌توان برچسب‌گذاری پیش‌فرض زیر را در نظر گرفت:
\begin{align*}
&l.h = \max \{ w(l, r) \mid r \in R \} &\forall l \in L\\
&r.h = 0 &\forall r \in R
\end{align*}
\itm
فرض کنید h یک برچسب‌گذاری مجاز باشد، زیرگراف تساوی $G_h = (V, E_h)$ دارای همان رأس‌های $G$ است ولی تنها شامل یال‌هایی است که در آن‌ها تساوی زیر برقرار باشد:
$$
E_h = \{ (l, r) \in E : l.h + r.h = w(l, r) \}
$$
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
قضیه‌ی زیر، رابطه‌ی بین تطابق کامل در زیرگراف تساوی و راه‌حل بهینه برای مسئله تخصیص را بیان می‌کند:
\itm
فرض کنید $h$ یک برچسب‌گذاری مجاز برای $G$ و $G_h$ زیرگراف تساوی متناظر باشد. اگر $M^*$ یک تطابق کامل روی $G_h$ باشد، آنگاه یک راه‌حل بهینه برای مسئله تخصیص روی $G$ نیز هست.
\itm
\textbf{اثبات:}
سودمندی $M^*$ برابر است با:
$$
w(M^\ast) = \sum_{(l, r) \in M^\ast} w(l, r)
$$
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
گفتیم در زیرگراف تساوی وزن یال برابر است با جمع برچسب‌های دو رأس آن پس:
$$
w(M^\ast) = \sum_{(l, r) \in M^\ast} w(l.h + r.h)
$$
\itm
از آنجا که $G_h$ و $G$ مجموعه رأس‌های یکسانی دارند $M^\ast$ یک تطابق کامل در $G$ نیز هست. در هر تطابق کامل، هر رأس دقیقاً در یک یال قرار دارد، بنابراین:
$$
w(M^\ast) = \sum_{l \in L} l.h + \sum_{r \in R} r.h
$$
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
حال باید ثابت کنیم سودمندی $M^\ast$ از هر تطابق کامل دلخواهی که روی گراف اصلی در نظر بگیریم بیشتر است. اگر $M$  را یک تطابق کامل دلخواه در نظر بگیریم سودمندی آن برابر است با:
$$
w(M) = \sum_{(l, r) \in M} w(l, r)
$$
\itm
در یک برچسب گذاری مجاز مجموع دو رأس یک یال از وزن آن بیشتر است بنابراین:
\begin{align*}
w(M) = \sum_{(l, r) \in M} w(l, r) \leq \sum_{(l, r) \in M} (l.h + r.h) = \sum_{l \in L} l.h + \sum_{r \in R} r.h
\end{align*}
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
دیدم که سودمندی $M^\ast$ برابر با
$$
\sum_{l \in L} l.h + \sum_{r \in R} r.h
$$
و سودمندی $M$ کمتر از این مقدار است پس سودمندی $M^\ast$ از هر تطابق کامل دلخواهی در $G‌$ بیشتر است.
\itm
پس حالا هدف یافتن یک تطابق کامل در یک زیرگراف تساوی است. اما کدام زیرگراف تساوی؟ مهم نیست!
نه‌تنها می‌توانیم زیرگراف برابری را انتخاب کنیم، بلکه در طول اجرای الگوریتم می‌توانیم آن را تغییر دهیم. تنها چیزی که نیاز داریم، یافتن یک تطابق کامل در یک زیرگراف برابری است.
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
بار دیگر یه این نامساوی که در اثبات قبل دیدیم دقت کنید:
\begin{align*}
w(M) \leq \sum_{l \in L} l.h + \sum_{r \in R} r.h
\end{align*}
\itm
فرض کردیم M یک تطابق کامل است. اما نامساوی با فرض اینکه M یک تطابق دلخواه باشد همچنان برقرار است.
\itm
یعنی مجموع برچسب رأس‌ها یک حد بالا برای وزن هر تطابق است.
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
حال که یک حد بالا برای مجموع وزن تطابق‌ها یافتیم، می‌خواهیم به صورت تکراری به این حد بالا نزدیک شویم.
\itm
فرض کنید h یک برچسب گذاری دلخواه باشد آنگاه تطابق با اندازه بیشینه
\fn{maximum-cardinality matching}
در این زیرگراف برابری، مجموع وزنی حداکثر برابر با مجموع برچسب‌ها خواهد داشت.
\itm
حال اگر برچسب‌گذاری h به‌درستی انتخاب شود، جمع برچسب‌ها برابر با $w(M^\ast)$ خواهد بود، و یک تطابق با اندازه بیشینه در آن زیرگراف برابری یک تطابق کامل با وزن بیشینه خواهد بود.
\itm
همانطور که ملاحظه کردید هم تطابق را باید به سمت تطابق با اندازه بیشینه تغییر دهیم و هم برچسب گذاری را تغییر دهیم تا به یک برچسب گذاری مناسب دست یابیم.
الگوریتم مجارستانی تطابق و برچسب‌گذاری رأس‌ها را به‌صورت مکرر تغییر می‌دهد تا به این هدف برسد.
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
این الگوریتم با یک برچسب‌گذاری مجاز اولیه و یک تطابق دلخواه در زیرگراف تساوی شروع می‌کند. سپس، به‌صورت تکراری، یک مسیر افزایشی نسبت به  M در $G_h$ پیدا می‌کند و تطابق را به $M \oplus P$ به‌روزرسانی می‌کند. به این ترتیب اندازه تطابق افزایش می‌یابد.
\itm
تا زمانی که زیرگرافی از تساوی وجود داشته باشد که شامل یک مسیر افزایشی نسبت به $M$ باشد، می‌توان اندازهٔ تطابق را افزایش داد. این روند ادامه می‌یابد تا یک تطابق کامل به‌دست آید.
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
ممکن است در این لحظه سوالات زیر برای شما پیش بیاید بیایید به هر کدام کوتاه پاسخ دهیم:
\itm
الگوریتم با چه برچسب‌گذاری مجاز اولیه‌ای شروع می‌کند؟\\
برچسب‌گذاری پیش‌فرض رأس‌ها که پیشتر تعریف شد و برچسب هر رأس سمت چپ را برابر با بیشترین وزن موجود در بین یال‌ها متصل به آن قرار می‌داد.
\itm
الگوریتم با چه تطابق اولیه‌ای شروع می‌کند؟\\
هر تطابقی، حتی تطابق تهی. اما یک تطابق حداکثری حاصل از یک الگوریتم حریصانه در اینجا به خوبی عمل می‌کند.
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
اگر مسیر افزایشی نسبت به M در $G_h$ وجود داشته باشد، چگونه می‌توان آن را یافت؟\\
با استفاده از نوعی جستجوی اول سطح؛ مشابه با آنچه در الگوریتم هاپکرافت-کارپ استفاده کردیم.
\itm
اگر جستجو برای مسیر افزایشی شکست بخورد چه باید کرد؟\\
برچسب‌گذاری رأس‌ها باید به‌روزرسانی شود تا حداقل یک یال جدید وارد زیرگراف تساوی شود.
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
در ادامه پاسخ سوالات بالا را با استفاده از مثال زیر نشان می‌دهیم:
\pic[.7]{7}
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
وزن یال‌ها در ماتریسی که در بخش a نشان داده شده و برچسب‌ها در سمت چپ و بالای ماتریس مشخص شده‌اند.
\itm
شکل b‌ گراف تساوی است و شکل c گرافی است جهت‌دار که همه رأس‌های موجود در M را راست به چپ و بقیه رأس‌ها را چپ به راست جهت دهی می‌کند.
\itm
مدخل‌های قرمز رنگ برای یال‌هایی‌اند که وزن آنها با جمع برچسب گذاری دو سر آن برابر است.
یعنی این یال‌ها در زیرگراف تساوی در بخش b وجود دارند.
\end{itemframe}


\begin{itemframe-s}{الگوریتم مجارستانی}{تطابق اولیهٔ حداکثری}
\itm
روش‌های مختلفی برای پیاده‌سازی یک الگوریتم حریصانه برای یافتن یک تطابق حداکثر‌ی دو بخشی وجود دارد. الگوریتم زیر یکی از این روش‌ها است.
\begin{algorithm}[H]\alglr
  \caption{GREEDY-BIPARTITE-MATCHING(G)}
  \begin{algorithmic}[1]
    \State $M = \emptyset$
    \For{each vertex $l \in L$}
      \If{$l$ has an unmatched neighbor in $R$}
        \State choose any such unmatched neighbor $r \in R$
        \State $M = M \cup {(l, r)}$
      \EndIf
    \EndFor
    \State \Return $M$
  \end{algorithmic}
\end{algorithm}
\itm
این الگوریتم تطابقی را بازمی‌گرداند که اندازه‌ی آن حداقل نیمی از اندازه‌ی تطابق بیشینه است.
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{تطابق اولیهٔ حداکثری}
\itm
در قسمت b این شکل، یال‌هایی که به رنگ آبی برجسته شده‌اند، تطابق اولیه‌ی حریصانه در $G_h$ را نشان می‌دهند.
\pic[.7]{7}
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{یافتن مسیر افزایشی}
\itm
برای یافتن یک مسیر افزایشی در زیرگراف تساوی، الگوریتم مجارستانی ابتدا زیرگراف تساوی جهت‌دار $G_{M,h}$ را از $G_h$ می‌سازد؛ دقیقاً همان‌گونه که الگوریتم هاپکرفت-کارپ، گراف $G_M$ را از $G$ می‌سازد.
\itm
مانند الگوریتم هاپکرفت-کارپ، می‌توانید مسیر افزایشی را به‌گونه‌ای تصور کنید که از یک رأس تطابق نیافته در $L$ آغاز می‌شود و به یک رأس تطابق نیافته در $R$ ختم می‌شود؛ پس در این مسیر یال‌های تطابق نیافته از $L$ به $R$ و یال‌هایی تطابق یافته از $R$ به $L$ طی می‌شوند.
\itm
پس یال‌های گراف $G_{M,h}$ را نیز به همین روال جهت دار می‌کنیم؛ یال‌های عضو تطابق به چپ و بقیهٔ یال‌ها به راست.
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{یافتن مسیر افزایشی}
\itm
شاید فکر کنید که ما با اینکار برخی مسیرها افزایشی را از دست می‌دهیم. اما در واقع با اینکار از مسیرهای افزایشی تکراری جلوگیری می‌کنیم.
\itm
تصور کنید دو مسیر دقیقاً با یال‌های یکسان اما جهت برعکس داشته باشیم. در نهایت زمانی که می‌خواهیم این مسیرها را با تفاضل متقارن اعمال کنیم جهت آنها تاثیری ندارد پس عملاً این دو مسیر یکسان هستند. پس یکی از جهت‌ها را قرارداد کرده و تنها مسیرهای افزایشی که در آن جهت هستند را در نظر می‌گیریم.
\itm
از آنجا که هر مسیر افزایشی نسبت به M در $G_{M,h}$، یک مسیر افزایشی در $G_h$ نیز محسوب می‌شود، کافی است مسیرهای افزایشی را در $G_{M,h}$ بیابیم.
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{یافتن مسیر افزایشی}
\itm
با در اختیار داشتن $G_{M,h}$ الگوریتم مجارستانی به دنبال یک مسیر افزایشی نسبت به M از هر رأس تطابق نیافته در $L$ به هر رأس تطابق نیافته در $R$ می‌گردد.
\itm
در اینجا از جست‌وجوی اول سطح برای این منظور استفاده می‌کنیم، که از تمام رأس‌های تطابق نیافته در $L$ شروع می‌شود. درست مانند الگوریتم هاپکرفت-کارپ با این تفاوت که بعد از یافتن اولین رأس تطابق نیافته در $R$ متوقف می‌شود.
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{یافتن مسیر افزایشی}
\itm
شکل زیر نحوه عملکرد این نوع جست‌وجوی اول سطح را نشان می‌دهد.
\pic{8}
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{یافتن مسیر افزایشی}
\itm
در مثال بالا، جست‌وجوی اول سطح مسیر زیر را یافته است:
$$
\langle (l_4, r_2), (r_2, l_1), (l_1, r_3), (r_3, l_6), (l_6, r_5) \rangle
$$

\itm
در این جست‌وجو ابتدا تمام رأس‌های تطابق در $L$ را در صف قرار می‌دهیم، نه فقط یک رأس مبدأ.
\itm
برخلاف گراف $H$ در الگوریتم هاپکرفت-کارپ، در اینجا هر رأس فقط به یک رأس قبلی نیاز دارد، بنابراین جست‌وجوی اول سطح، یک جنگل اول سطح
\fn{breadth-first forest}
به نام $F = (V_F, E_F)$ ایجاد می‌کند، به طوری که هر رأس تطابق نیافته در $L$ یک ریشه در $F$ است.
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{یافتن مسیر افزایشی}
\itm
در قسمت a از شکل زیر تطابق جدید را نشان داده شده که از طریق گرفتن تفاضل متقارن بین مسیر افزایشی به‌دست آمده و تطابق است.
\pic{9}
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{وقتی مسیر افزایشی یافت نشود}
\itm
پس از به‌روزرسانی تطابق الگوریتم مجارستانی زیرگراف تساوی را با توجه به تطابق جدید به‌روزرسانی می‌کند و سپس جست‌وجوی اول سطح جدیدی را از تمام رأس‌های تطابق نیافته در $L$ آغاز می‌نماید. بیاید با استفاده از همان مثال قبلی آغاز این فرایند را ببینیم:
\pic{10}
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{وقتی مسیر افزایشی یافت نشود}
\itm
در قسمت d شکل بالا صف شامل رأس‌های
$l_4$ و
$l_3$
است. با این حال، هیچ‌یک از این رأس‌ها یالی ندارند که از آن‌ها خارج شود، بنابراین زمانی که این رأس‌ها از صف خارج می‌شوند، صف خالی می‌گردد. در این نقطه، جست‌وجو متوقف می‌شود، بدون آن‌که رأس تطابق نیافته‌ایی در $R$ یافته شده باشد تا یک مسیر افزایشی پیدا شود.
\itm
به یاد داشته باشید که می‌توانیم با هر زیرگراف تساوی دلخواه کار کنیم. می‌توانیم زیرگراف تساوی جهت‌دار را در لحظه تغییر دهیم، به شرطی که تلاش‌های پیشین خنثی نشوند. الگوریتم مجارستانی برچسب‌گذاری رأس‌ها را به‌گونه‌ای به‌روزرسانی می‌کند که شرایط زیر برقرار باشند:
\itm
هیچ یالی از جنگل اول‌سطح از زیرگراف تساوی جهت‌دار خارج نشود.
\itm
هیچ یالی از تطابق از زیرگراف برابری جهت‌دار خارج نشود.
\itm
دست‌کم یک یال $(l, r)$، که در آن $l \in L \setminus V_F$ و $r \in R \setminus V_F$، وارد مجموعه $E_h$ شود و بنابراین وارد $E_{M,h}$ نیز بشود. در نتیجه، دست‌کم یک رأس در $R$ به‌تازگی کشف خواهد شد.
\end{itemframe-s}
\iffalse





\fi
