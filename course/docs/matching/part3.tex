\begin{itemframe}{الگوریتم مجارستانی}
\itm
بیایید بار دیگر اطلاعاتی را به یک گراف دو بخشی \textbf{کامل} اضافه کنیم است.
این بار به هر یال یک وزن اختصاص می‌دهیم.
دوباره فرض می‌کنیم مجموعه‌های $L$ و $R$ هر یک شامل $n$ رأس هستند، بنابراین گراف دارای
$n^2$
یال خواهد بود.
\itm
برای $l \in L$ و $r \in R$، وزن یال $(l, r)$ را با $w(l, r)$ نمایش می‌دهیم که نشان‌دهنده‌ی میزان سودی است که از تطبیق رأس $l$ با رأس $r$ به دست می‌آید.
\itm
یک تطابق کامل
\fn{perfect matching}
 تطابقی است که تحت آن همه رأس‌ها تطابق‌یافته باشند.

\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
در این مسئله هدف یافتن یک تطابق کامل مانند
$M^*$
 است به‌طوری‌که مجموع وزن یال‌های آن، در میان همه تطابق‌های کامل، بیشینه باشد.
به این مسئله،‌ مسئله تخصیص
\fn{assignment problem}
 گفته می‌شود.
\itm
بررسی تمام تطابق‌های کامل از مرتبه
$ \Omega (n!)$
است. اما الگوریتمی به نام الگوریتم مجارستانی
\fn{Hungarian algorithm}
 این مسئله را بسیار سریع‌تر حل می‌کند.
\itm
این الگوریتم ا زمرتبه زمانی
$O(n^4)$
 است.
(البته می‌توان زمان اجرای آن را به
$O(n^3)$
 کاهش داد.)
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
الگوریتم مجارستانی به جای کار با گراف دوبخشی کامل $G$، با زیرگرافی از آن به نام زیرگراف تساوی
\fn{equality subgraph}
کار می‌کند.
این زیرگراف به‌صورت پویا تغییر می‌کند و هر تطابق کامل در زیرگراف تساوی، یک راه‌حل بهینه برای مسئله تخصیص نیز هست.
\itm
زیرگراف تساوی با تخصیص یک عدد به هر رأس ساخته می‌شود. به این عدد برچسب رأس گفته می‌شود و با h نشان داده می‌شود.
\itm
می‌گوییم $h$ یک برچسب‌گذاری مجاز
\fn{feasible labeling}
است اگر برای همه $l \in L$ و $r \in R$ رابطه زیر برقرار باشد:
$$l.h + r.h \geq w(l, r)$$
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
یک برچسب‌گذاری مجاز همواره وجود دارد. به عنوان مثال، می‌توان برچسب‌گذاری پیش‌فرض زیر را در نظر گرفت:
\begin{align*}
&l.h = \max \{ w(l, r) \mid r \in R \} &\forall l \in L\\
&r.h = 0 &\forall r \in R
\end{align*}
\itm
فرض کنید h یک برچسب‌گذاری مجاز باشد، زیرگراف تساوی $G_h = (V, E_h)$ دارای همان رأس‌های $G$ است ولی تنها شامل یال‌هایی است که در آن‌ها تساوی زیر برقرار باشد:
$$
E_h = \{ (l, r) \in E : l.h + r.h = w(l, r) \}
$$
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
قضیه‌ی زیر، رابطه‌ی بین تطابق کامل در زیرگراف تساوی و راه‌حل بهینه برای مسئله تخصیص را بیان می‌کند:
\itm
فرض کنید $h$ یک برچسب‌گذاری مجاز برای $G$ و $G_h$ زیرگراف تساوی متناظر باشد. اگر $M^*$ یک تطابق کامل روی $G_h$ باشد، آنگاه یک راه‌حل بهینه برای مسئله تخصیص روی $G$ نیز هست.
\itm
\textbf{اثبات:}
سودمندی $M^*$ برابر است با:
$$
w(M^\ast) = \sum_{(l, r) \in M^\ast} w(l, r)
$$
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
گفتیم در زیرگراف تساوی وزن یال برابر است با جمع برچسب‌های دو رأس آن پس:
$$
w(M^\ast) = \sum_{(l, r) \in M^\ast} w(l.h + r.h)
$$
\itm
از آنجا که $G_h$ و $G$ مجموعه رأس‌های یکسانی دارند $M^\ast$ یک تطابق کامل در $G$ نیز هست. در هر تطابق کامل، هر رأس دقیقاً در یک یال قرار دارد، بنابراین:
$$
w(M^\ast) = \sum_{l \in L} l.h + \sum_{r \in R} r.h
$$
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
حال باید ثابت کنیم سودمندی $M^\ast$ از هر تطابق کامل دلخواهی که روی گراف اصلی در نظر بگیریم بیشتر است. اگر $M$  را یک تطابق کامل دلخواه در نظر بگیریم سودمندی آن برابر است با:
$$
w(M) = \sum_{(l, r) \in M} w(l, r)
$$
\itm
در یک برچسب گذاری مجاز مجموع دو رأس یک یال از وزن آن بیشتر است بنابراین:
\begin{align*}
w(M) = \sum_{(l, r) \in M} w(l, r) \leq \sum_{(l, r) \in M} (l.h + r.h) = \sum_{l \in L} l.h + \sum_{r \in R} r.h
\end{align*}
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
دیدم که سودمندی $M^\ast$ برابر با
$$
\sum_{l \in L} l.h + \sum_{r \in R} r.h
$$
و سودمندی $M$ کمتر از این مقدار است پس سودمندی $M^\ast$ از هر تطابق کامل دلخواهی در $G‌$ بیشتر است.
\itm
پس حالا هدف یافتن یک تطابق کامل در یک زیرگراف تساوی است. اما کدام زیرگراف تساوی؟ مهم نیست!
نه‌تنها می‌توانیم زیرگراف برابری را انتخاب کنیم، بلکه در طول اجرای الگوریتم می‌توانیم آن را تغییر دهیم. تنها چیزی که نیاز داریم، یافتن یک تطابق کامل در یک زیرگراف برابری است.
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
بار دیگر یه این نامساوی که در اثبات قبل دیدیم دقت کنید:
\begin{align*}
w(M) \leq \sum_{l \in L} l.h + \sum_{r \in R} r.h
\end{align*}
\itm
فرض کردیم M یک تطابق کامل است. اما نامساوی با فرض اینکه M یک تطابق دلخواه باشد همچنان برقرار است.
\itm
یعنی مجموع برچسب رأس‌ها یک حد بالا برای وزن هر تطابق است.
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
حال که یک حد بالا برای مجموع وزن تطابق‌ها یافتیم، می‌خواهیم به صورت تکراری به این حد بالا نزدیک شویم.
\itm
فرض کنید h یک برچسب گذاری دلخواه باشد آنگاه تطابق با اندازه بیشینه
\fn{maximum-cardinality matching}
در این زیرگراف برابری، مجموع وزنی حداکثر برابر با مجموع برچسب‌ها خواهد داشت.
\itm
حال اگر برچسب‌گذاری h به‌درستی انتخاب شود، جمع برچسب‌ها برابر با $w(M^\ast)$ خواهد بود، و یک تطابق با اندازه بیشینه در آن زیرگراف برابری یک تطابق کامل با وزن بیشینه خواهد بود.
\itm
همانطور که ملاحظه کردید هم تطابق را باید به سمت تطابق با اندازه بیشینه تغییر دهیم و هم برچسب گذاری را تغییر دهیم تا به یک برچسب گذاری مناسب دست یابیم.
الگوریتم مجارستانی تطابق و برچسب‌گذاری رأس‌ها را به‌صورت مکرر تغییر می‌دهد تا به این هدف برسد.
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
این الگوریتم با یک برچسب‌گذاری مجاز اولیه و یک تطابق دلخواه در زیرگراف تساوی شروع می‌کند. سپس، به‌صورت تکراری، یک مسیر افزایشی نسبت به  M در $G_h$ پیدا می‌کند و تطابق را به $M \oplus P$ به‌روزرسانی می‌کند. به این ترتیب اندازه تطابق افزایش می‌یابد.
\itm
تا زمانی که زیرگرافی از تساوی وجود داشته باشد که شامل یک مسیر افزایشی نسبت به $M$ باشد، می‌توان اندازهٔ تطابق را افزایش داد. این روند ادامه می‌یابد تا یک تطابق کامل به‌دست آید.
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
ممکن است در این لحظه سوالات زیر برای شما پیش بیاید بیایید به هر کدام کوتاه پاسخ دهیم:
\itm
الگوریتم با چه برچسب‌گذاری مجاز اولیه‌ای شروع می‌کند؟\\
برچسب‌گذاری پیش‌فرض رأس‌ها که پیشتر تعریف شد و برچسب هر رأس سمت چپ را برابر با بیشترین وزن موجود در بین یال‌ها متصل به آن قرار می‌داد.
\itm
الگوریتم با چه تطابق اولیه‌ای شروع می‌کند؟\\
هر تطابقی، حتی تطابق تهی. اما یک تطابق حداکثری حاصل از یک الگوریتم حریصانه در اینجا به خوبی عمل می‌کند.
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
اگر مسیر افزایشی نسبت به M در $G_h$ وجود داشته باشد، چگونه می‌توان آن را یافت؟\\
با استفاده از نوعی جستجوی اول سطح؛ مشابه با آنچه در الگوریتم هاپکرافت-کارپ استفاده کردیم.
\itm
اگر جستجو برای مسیر افزایشی شکست بخورد چه باید کرد؟\\
برچسب‌گذاری رأس‌ها باید به‌روزرسانی شود تا حداقل یک یال جدید وارد زیرگراف تساوی شود.
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
در ادامه پاسخ سوالات بالا را با استفاده از مثال زیر نشان می‌دهیم:
\pic[.7]{7}
\end{itemframe}


\begin{itemframe}{الگوریتم مجارستانی}
\itm
وزن یال‌ها در ماتریسی که در بخش a نشان داده شده و برچسب‌ها در سمت چپ و بالای ماتریس مشخص شده‌اند.
\itm
شکل b‌ گراف تساوی است و شکل c گرافی است جهت‌دار که همه رأس‌های موجود در M را راست به چپ و بقیه رأس‌ها را چپ به راست جهت دهی می‌کند.
\itm
مدخل‌های قرمز رنگ برای یال‌هایی‌اند که وزن آنها با جمع برچسب گذاری دو سر آن برابر است.
یعنی این یال‌ها در زیرگراف تساوی در بخش b وجود دارند.
\end{itemframe}


\begin{itemframe-s}{الگوریتم مجارستانی}{تطابق اولیهٔ حداکثری}
\itm
روش‌های مختلفی برای پیاده‌سازی یک الگوریتم حریصانه برای یافتن یک تطابق حداکثر‌ی دو بخشی وجود دارد. الگوریتم زیر یکی از این روش‌ها است.
\begin{algorithm}[H]\alglr
  \caption{GREEDY-BIPARTITE-MATCHING(G)}
  \begin{algorithmic}[1]
    \State $M = \emptyset$
    \For{each vertex $l \in L$}
      \If{$l$ has an unmatched neighbor in $R$}
        \State choose any such unmatched neighbor $r \in R$
        \State $M = M \cup {(l, r)}$
      \EndIf
    \EndFor
    \State \Return $M$
  \end{algorithmic}
\end{algorithm}
\itm
این الگوریتم تطابقی را بازمی‌گرداند که اندازه‌ی آن حداقل نیمی از اندازه‌ی تطابق بیشینه است.
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{تطابق اولیهٔ حداکثری}
\itm
در قسمت b این شکل، یال‌هایی که به رنگ آبی برجسته شده‌اند، تطابق اولیه‌ی حریصانه در $G_h$ را نشان می‌دهند.
\pic[.7]{7}
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{یافتن مسیر افزایشی}
\itm
برای یافتن یک مسیر افزایشی در زیرگراف تساوی، الگوریتم مجارستانی ابتدا زیرگراف تساوی جهت‌دار $G_{M,h}$ را از $G_h$ می‌سازد؛ دقیقاً همان‌گونه که الگوریتم هاپکرفت-کارپ، گراف $G_M$ را از $G$ می‌سازد.
\itm
مانند الگوریتم هاپکرفت-کارپ، می‌توانید مسیر افزایشی را به‌گونه‌ای تصور کنید که از یک رأس تطابق نیافته در $L$ آغاز می‌شود و به یک رأس تطابق نیافته در $R$ ختم می‌شود؛ پس در این مسیر یال‌های تطابق نیافته از $L$ به $R$ و یال‌هایی تطابق یافته از $R$ به $L$ طی می‌شوند.
\itm
پس یال‌های گراف $G_{M,h}$ را نیز به همین روال جهت دار می‌کنیم؛ یال‌های عضو تطابق به چپ و بقیهٔ یال‌ها به راست.
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{یافتن مسیر افزایشی}
\itm
شاید فکر کنید که ما با اینکار برخی مسیرها افزایشی را از دست می‌دهیم. اما در واقع با اینکار از مسیرهای افزایشی تکراری جلوگیری می‌کنیم.
\itm
تصور کنید دو مسیر دقیقاً با یال‌های یکسان اما جهت برعکس داشته باشیم. در نهایت زمانی که می‌خواهیم این مسیرها را با تفاضل متقارن اعمال کنیم جهت آنها تاثیری ندارد پس عملاً این دو مسیر یکسان هستند. پس یکی از جهت‌ها را قرارداد کرده و تنها مسیرهای افزایشی که در آن جهت هستند را در نظر می‌گیریم.
\itm
از آنجا که هر مسیر افزایشی نسبت به M در $G_{M,h}$، یک مسیر افزایشی در $G_h$ نیز محسوب می‌شود، کافی است مسیرهای افزایشی را در $G_{M,h}$ بیابیم.
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{یافتن مسیر افزایشی}
\itm
با در اختیار داشتن $G_{M,h}$ الگوریتم مجارستانی به دنبال یک مسیر افزایشی نسبت به M از هر رأس تطابق نیافته در $L$ به هر رأس تطابق نیافته در $R$ می‌گردد.
\itm
در اینجا از جست‌وجوی اول سطح برای این منظور استفاده می‌کنیم، که از تمام رأس‌های تطابق نیافته در $L$ شروع می‌شود. درست مانند الگوریتم هاپکرفت-کارپ با این تفاوت که بعد از یافتن اولین رأس تطابق نیافته در $R$ متوقف می‌شود.
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{یافتن مسیر افزایشی}
\itm
شکل زیر نحوه عملکرد این نوع جست‌وجوی اول سطح را نشان می‌دهد.
\pic[.4]{8}
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{یافتن مسیر افزایشی}
\itm
در مثال بالا، جست‌وجوی اول سطح مسیر زیر را یافته است:
$$
\langle (l_4, r_2), (r_2, l_1), (l_1, r_3), (r_3, l_6), (l_6, r_5) \rangle
$$

\itm
در این جست‌وجو ابتدا تمام رأس‌های تطابق در $L$ را در صف قرار می‌دهیم، نه فقط یک رأس مبدأ.
\itm
برخلاف گراف $H$ در الگوریتم هاپکرفت-کارپ، در اینجا هر رأس فقط به یک رأس قبلی نیاز دارد، بنابراین جست‌وجوی اول سطح، یک جنگل اول سطح
\fn{breadth-first forest}
به نام $F = (V_F, E_F)$ ایجاد می‌کند، به طوری که هر رأس تطابق نیافته در $L$ یک ریشه در $F$ است.
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{یافتن مسیر افزایشی}
\itm
در قسمت a از شکل زیر تطابق جدید را نشان داده شده که از طریق گرفتن تفاضل متقارن بین مسیر افزایشی به‌دست آمده و تطابق است.
\pic{9}
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{وقتی مسیر افزایشی یافت نشود}
\itm
پس از به‌روزرسانی تطابق الگوریتم مجارستانی زیرگراف تساوی را با توجه به تطابق جدید به‌روزرسانی می‌کند و سپس جست‌وجوی اول سطح جدیدی را از تمام رأس‌های تطابق نیافته در $L$ آغاز می‌نماید. بیاید با استفاده از همان مثال قبلی آغاز این فرایند را ببینیم:
\pic{10}
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{وقتی مسیر افزایشی یافت نشود}
\itm
در قسمت d شکل بالا صف شامل رأس‌های
$l_4$ و
$l_3$
است. با این حال، هیچ‌یک از این رأس‌ها یالی ندارند که از آن‌ها خارج شود، بنابراین زمانی که این رأس‌ها از صف خارج می‌شوند، صف خالی می‌گردد. در این نقطه، جست‌وجو متوقف می‌شود، بدون آن‌که رأس تطابق نیافته‌ایی در $R$ یافته شده باشد تا یک مسیر افزایشی پیدا شود.
\itm
هرگاه چنین وضعیتی رخ دهد، آخرین رأس‌های کشف شده
\fn{discoverd}
الزاماً متعلق به $L$ هستند. زیرا هر گاه که یک رأس در $R$ شود؛
\item[1]
اگر تطابق نیافته باشد یک مسیر افزایشی پیدا شده است،
\item[2]
و اگر تطابق‌یافته باشد، همسایه‌ٔ کشف‌نشده‌ای در $L$ دارد پس جست‌وجو ادامه می‌یابد.
\itm
منظور از کشف اولین باری است که در جست‌وجو با یک رأس مواجه می‌شویم و آن را به صف اضافه می‌کنیم.
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{وقتی مسیر افزایشی یافت نشود}
\itm
به یاد داشته باشید که می‌توانیم با هر زیرگراف تساوی دلخواه کار کنیم. بنابراین می‌توانیم آن را تغییر دهیم. البته، به شرطی که تلاش‌های پیشین خراب نشوند. برای این منظور باید شرایط زیر برقرار باشند:
\item[1]
هیچ یالی از جنگل اول‌سطح از زیرگراف تساوی جهت‌دار خارج نشود.
\item[2]
هیچ یالی از تطابق از زیرگراف تساوی جهت‌دار خارج نشود.
\item[3]
دست‌کم یک یال $(l, r)$، که در آن
$l \in L - V_F$
 و
$r \in R - V_F$،
وارد مجموعه $E_h$ شود و بنابراین وارد $E_{M,h}$ نیز بشود. در نتیجه، دست‌کم یک رأس کشف نشده در $R$ اضافه می‌شود.
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{وقتی مسیر افزایشی یافت نشود}
\itm
بنابراین، حداقل یک یال جدید وارد زیرگراف تساوی می‌شود و هر یال می شود.
و هر یالی که از زیرگراف تساوی حذف می‌شود، به M و F تعلق ندارد.
\itm
برای به‌روزرسانی برچسب‌گذاری، الگوریتم مجارستانی ابتدا مقدار زیر را محاسبه می‌کند:
$$
\delta = \min \{ l.h + r.h - w(l, r) : l \in F_L \text{ and } r \in R - F_R \}
$$

\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{وقتی مسیر افزایشی یافت نشود}
\itm
که در آن
$F_L = L \cap V_F$ و
$F_R = R \cap V_F$
به ترتیب رئوس متعلق به مجموعهٔ $L$ و $R$ در جنگل $F$ هستند.
\itm
به عبارت دیگر،
دلتا نشان می‌دهد از بین یال‌هایی که امکان اضافه شدن را دارند کدام یک به تفاوت کمتری بین یال و برچسب دو طرف دارد. در واقع این یال کمترین فاصله را برای اضافه شدن به تطابق دارد.


\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{وقتی مسیر افزایشی یافت نشود}
\itm
سپس، الگوریتم مجارستانی یک برچسب‌گذاری مجاز جدید، مثلاً
$h'$،
ایجاد می‌کند، که در آن به ازای هر رأس
$l \in F_L$
مقدار دلتا از
$l.h$
کم می‌شود، و به ازای هر رأس
$r \in F_R$
مقدار دلتا
به
$r.h$
افزوده می‌شود. این برچسب‌گذاری جدید به‌صورت زیر تعریف می‌شود:
$$
v.h' =
\begin{cases}
v.h - \delta & \text{ if } v \in F_L \\
v.h + \delta & \text{ if } v \in F_R \\
v.h & \text{ otherwise } \text{)} v \in V - V_F \text{(}
\end{cases}
$$
\itm
نشان داده می‌شود که این تغییرات به سه معیاری که پیش‌تر ذکر شد را رعایت می‌کنند.
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{مثال اجرای الگوریتم مجارستانی}
\itm
بیایید مثال قبلی خودمان را ادامه دهیم؛
تا آنجا رسیدیم که صف پیش از یافتن یک مسیر افزایشی خالی شد.
\pic{10}
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{مثال اجرای الگوریتم مجارستانی}
\itm
مقدار
$\delta = 1$
توسط یال
$(l_5, r_3)$
حاصل می‌شود. به شکل زیر دقت کنید:

\pic{7}

$$
 l_5.h + r_3.h - w(l_5, r_3) = 6 + 0 - 5 = 1
$$
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{مثال اجرای الگوریتم مجارستانی}
\itm
شکل زیر گام‌های بعدی الگوریتم را نشان می‌دهد:
\pic[.7]{11}
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{مثال اجرای الگوریتم مجارستانی}
\itm
همانطور که مشاهده می‌کنید، مقادیر
$l_3.h$،
$l_4.h$،
$l_5.h$، و
$l_7.h$
۱ واحد کاهش و مقادیر
$r_2.h$ و
$r_7.h$
۱ واحد افزایش یافته‌اند، زیرا این رأس‌ها در $F$ قرار دارند.
\itm
در نتیجه، یال‌های
$(l_1, r_2)$ و
$(l_6, r_7)$
 از $G{M, h}$ خارج شده و یال
$(l_5, r_3)$
وارد آن شده است.
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{مثال اجرای الگوریتم مجارستانی}
\itm

شکل زیر قسمت b زیرگراف تساوی جدید را نشان می‌دهد.
با ورود یال
$(l_5, r_3)$
در قسمت c مشاهده می‌کنیم که این یال به $F$ افزوده شده و رأس
$r_3$
به صف افزوده شده است.

\pic[.7]{12}
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{مثال اجرای الگوریتم مجارستانی}
\itm
بخش‌های c تا f شکل قبل ادامهٔ ساخت جنگل اول‌سطح را نشان می‌دهند تا اینکه در بخش f صف پس از حذف رأس
$l_2$،
بار دیگر خالی می‌شود.
\itm
بنابراین، الگوریتم باید مجدداً برچسب‌گذاری‌ها را به‌روزرسانی کند. این‌بار مقدار
$\delta = 1$
توسط سه یال حاصل می‌شود:
$$
(l_1, r_6), (l_5, r_6),  (l_7, r_6)
$$
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{مثال اجرای الگوریتم مجارستانی}
\itm
همان‌طور که شکل زیر در قسمت‌های a و b نشان داده شده، این یال‌ها وارد شده‌اند و یال
$(l_6, r_3)$
خارج شده است.

بخش c نشان می‌دهد که یال $(l_1, r_6)$ به جنگل افزوده شده است. (یال‌های $(l_5, r_6)$ یا $(l_7, r_6)$ نیز می‌توانستند به جای آن افزوده شوند.)
\itm
از آنجا که
$r_6$
تطابق نیافته است، جست‌وجو مسیر افزایشی زیر را یافته است:
$$
\langle (l_5, r_3), (r_3, l_1), (l_1, r_6) \rangle
$$
این مسیر در شکل بالا با رنگ نارنجی مشخص شده است.

\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{مثال اجرای الگوریتم مجارستانی}
\itm
شکل زیر $G_{M,h}$ را پس از به‌روزرسانی تطابق توسط گرفتن تفاضل متقارن آن با مسیر افزایشی  نشان می‌دهد.
\pic{14}

\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{مثال اجرای الگوریتم مجارستانی}
\itm
الگوریتم مجارستانی جست‌وجوی اول سطح نهایی خود را آغاز می‌کند. (تنها با رأس
$l_7$
به‌عنوان تنها ریشه) جست‌وجو طبق بخش‌های b تا h شکل ادامه می‌یابد، تا زمانی که صف پس از حذف رأس
$l_4$
خالی شود.
\itm
این بار، داریم
$\delta = 2$
، که توسط پنج یال زیر حاصل می‌شود:
$$
(l_2, r_5),  (l_3, r_1),  (l_4, r_5),  (l_5, r_1),  (l_5, r_5)
$$
هر یک از این یال‌ها وارد $G_{M,h}$ می‌شوند.


\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{مثال اجرای الگوریتم مجارستانی}
\itm
قسمت a از شکل زیر نتیجهٔ کاهش مقدار برچسب رأس‌های $F_L$ به‌اندازهٔ ۲ و افزایش مقدار برچسب رأس‌های $F_R$ به‌اندازهٔ ۲ را نشان می‌دهد.
\pic{14}
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{مثال اجرای الگوریتم مجارستانی}
\itm
و قسمت b این شکل زیرگراف برابری جهت‌دار حاصل را نمایش می‌دهد.
 همچنین قسمت c نشان می‌دهد که یال
$(l_3, r_1)$
به جنگل اول‌سطح افزوده شده است.
\pic{15}
\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{مثال اجرای الگوریتم مجارستانی}
\itm
از آنجا که
$r_1$
یک رأس تطابق نیافته است، جست‌وجو خاتمه یافته و مسیر افزایشی
$$
\langle (l_7, r_7), (r_7, l_3), (l_3, r_1) \rangle
$$
که با رنگ نارنجی برجسته شده، یافته می‌شود. اگر
$r_1$
تطابق یافته بود، رأس
$r_5$
نیز به جنگل اول‌سطح اضافه می‌شد، که هر یک از
$l_2$،
$l_4$، یا
$l_5$
والد آن بودند.

\end{itemframe-s}


\begin{itemframe-s}{الگوریتم مجارستانی}{مثال اجرای الگوریتم مجارستانی}
\itm
پس از به‌روزرسانی $M$، الگوریتم به یک تطابق کامل برای زیرگراف تساوی می‌رسد. می‌دانیم این تطابق کامل برای زیر گراف برابری، یک جواب بهینه برای مسئله تخصیص اصلی است.
\pic[.45]{16}
\end{itemframe-s}