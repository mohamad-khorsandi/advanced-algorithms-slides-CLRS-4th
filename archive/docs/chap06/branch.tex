\iffalse
\begin{frame}{شاخه و کران}
\begin{itemize}\itemr
\item[-]
روش شاخه و کران
\fn{1}{branch and bound}
برای بهبود الگوریتم‌های پسگرد به کار می‌روند.
\item[-]
روش شاخه و کران، همچون روش پسگرد درخت فضای حالت را برای یافتن جواب بررسی می‌کند.
\item[-]
یک الگوریتم شاخه و کران در هر رأس درخت جستجوی حالات،
کرانی را محاسبه می‌کند که با استفاده از مقدار کران می‌توان گفت آیا آن رأس
 امید دهنده است یا خیر. مقداری که به عنوان کران در هر رأس محاسبه می‌شود، با استفاده از کرانی بر روی جواب مسئله به دست می‌آید.
\end{itemize}
\end{frame}
\fi

\begin{frame}{شاخه و کران}
\begin{itemize}\itemr
\item[-]
روش شاخه و کران
\fn{1}{branch and bound}
 همچون روش پسگرد درخت فضای حالت را برای یافتن جواب بررسی می‌کند.
\item[-]
این روش معمولاً برای مسائل بهینه‌سازی استفاده می‌شود. در مسائل بهینه‌سازی هدف یافتن جواب بهینه (کوچکترین، بزرگترین، ...) است. در هر لحظه در هنگام پیمایش درخت فضای حالت یکی از جواب‌های به دست آمده تا آن لحظه بهینه است. بنابراین قبل از بسط دادن یک رأس می‌توانیم محاسبه کنیم آیا جوابی که با بسط دادن آن رأس به دست می‌آید، از جواب بهینه‌ای که تا آن لحظه به دست آمده است، بهتر است یا خیر. در صورتی که امیدی به یافتن جواب بهتر نبود، رأس مورد پیمایش بسط داده نمی‌شود.
\item[-]
بنابراین اگر با بسط دادن یک رأس امید به یافتن جواب بهینه‌تر وجود نداشت، می‌گوییم آن رأس نومیدکننده
\fn{2}{nonpromising}
است، در غیر اینصورت امیددهنده
\fn{3}{promising}
است.
یک الگوریتم شاخه و کران در هر رأس درخت جستجوی حالات،
کرانی را محاسبه می‌کند که با استفاده از مقدار کران می‌توان گفت آیا آن رأس
 امید دهنده است یا خیر.
\end{itemize}
\end{frame}


\begin{frame}{شاخه و کران}
\begin{itemize}\itemr
\item[-]
می‌توانیم مسئلهٔ کوله پشتی ۱-۰ را با استفاده از روش پسگرد حل کنیم.
\item[-]
در سطح اول در درخت فضای حالت، دو حالت بررسی می‌شوند : (۱) کالای اول در کوله پشتی قرار می‌گیرد، یا (۲) کالای اول در کوله‌پشتی قرار نمی‌گیرد. همینطور در سطح دوم به ازای هر یک از دو حالت سطح اول درخت، باید دو حالت بررسی شوند : اینکه کالای دوم در کوله‌پشتی قرار می‌گیرد یا نمی‌گیرد.
این فرایند ادامه پیدا می‌کند تا به یک جواب برسیم و هزینه کوله‌پشتی را محاسبه کنیم. در یک الگوریتم پسگرد باید همهٔ برگ‌های درخت فضای حالت بررسی شده، برگی که بیشترین هزینه را دارد انتخاب شود. 
\end{itemize}
\end{frame}

\begin{frame}{شاخه و کران}
\begin{itemize}\itemr
\item[-]
همچنین در حل این مسئله
 می‌توان از روش شاخه و کران استفاده کرد. برای بررسی اینکه
 یک رأس امیددهنده است یا خیر،
باید محاسبه کنیم که آیا حداکثر ارزشی که می‌تواند با برداشتن باقی اشیاء حاصل شود، از جواب بهینهٔ به دست آمده تا آن لحظه بیشتر است یا خیر.
تنها در صورتی بسط یک رأس را ادامه می‌دهیم که امیدی به بهبود جواب داشته باشیم.
\item[-]
یک الگوریتم شاخه و کران به ازای هر رأس در درخت فضای حالت محاسبه می‌کند آیا هزینه‌ای که با بسط آن رأس به دست می‌آید از جواب بهینه به دست آمده بهتر خواهد بود یا خیر. به عبارت دیگر می‌گوییم در هر رأس یک کران محاسبه می‌شود و با استفاده از کران محاسبه شده تصمیم گرفته می‌شود رأس مورد بررسی هرس شود یا خیر.
%\item[-]
%در هر لحظه در حین اجرای الگوریتم پسگرد، یکی از جواب های به دست آمده جواب بهینه است. در هر رأس درخت فضای حالت برای اجناس باقیمانده خارج از کوله پشتی یک کران بالا با استفاده از الگوریتم حریصانه (با فرض این که اجناس را می‌توان تقسیم کرد) به دست می‌آوریم. اگر مقدار این کران بالا از جواب بهینه به دست آمده تا آن لحظه کمتر بود، آن رأس را بسط نمی‌دهیم زیرا امیدی به پیدا کردن جواب بهینه با بسط آن رأس وجود نخواهد داشت.
\end{itemize}
\end{frame}

\begin{frame}{شاخه و کران}
\begin{itemize}\itemr
\item[-]
در روش شاخه و کران، با استفاده از مقدار کران به دست آمده، نه تنها می‌توان تصمیم گرفت که یک رأس بسط داده شود و یا خیر، بلکه می‌توان علاوه بر آن با استفاده از کران به دست آمده، تصمیم گرفت کدام رأس برای بسط دادن مناسب‌تر است.
\item[-]
با استفاده از این روش معمولاً می‌توان با سرعت بیشتری به جواب بهینه دست پیدا کرد.
\item[-]
به این روش جستجوی بهتر اول
\fn{1}{best-first search}
با هرس کردن شاخه و کران
\fn{2}{branch and bound pruning}
گفته می‌شود.
\end{itemize}
\end{frame}


\begin{frame}{شاخه و کران}
\begin{itemize}\itemr
\item[-]
در جستجوی بهتر اول، درخت فضای حالت را با استفاده از جستجوی سطح اول
\fn{1}{breadth-first search}
 پیمایش می‌کنیم.
%در جستجوی درخت فضای حالت گاهی به جای جستجوی عمق اول، از جستجوی سطح اول
%\fn{1}{breadth-first search}
%استفاده می‌شود.
\item[-]
در پیمایش سطح اول، ابتدا ریشه بررسی می‌شود، سپس رئوس سطح یک و پس از آن رئوس سطح دو و بدین ترتیب همهٔ رئوس تا برگ‌ها بررسی می‌شوند.
\item[-]
برخلاف جستجوی عمق اول که در آن از یک الگوریتم بازگشتی استفاده می‌شود، در جستجوی سطح-اول از یک صف برای پیمایش رئوس درخت استفاده می‌کنیم.
\item[-]
بدین ترتیب فرزندان یک رأس در صف قرار می‌گیرند و به ترتیب فرزندان یک به یک از صف خارج شده و فرزندانشان پیمایش می‌شوند. بنابراین در این روش ابتدا سطح اول درخت، سپس سطح دوم و به همین ترتیب همهٔ سطوح پیمایش می‌شوند. به همین دلیل به این جستجو سطح-اول گفته می‌شود.
\end{itemize}
\end{frame}


\begin{frame}{شاخه و کران}
\begin{itemize}\itemr
\item[-]
الگوریتم زیر الگوریتم جستجوی درخت با استفاده از روش سطح-اول را نشان می‌دهد.
\begin{algorithm}[H]\alglr
  \caption{Breadth-First-Tree-Search} 
  \begin{algorithmic}[1]
   \Func{Breadth-First-Tree-Search}{tree T}
   \State queue Q
   \State node u, v
   \State initialize(Q)		\LeftComment{initialize Q to be empty.}
   \State u = root(T)
   \State visit(u)
   \State enqueue(Q, u)
   \While{!empty(Q)}
   		\State v = dequeue(Q)
   		\For{each child u of v}
   				\State visit(u)
   				\State enqueue(Q, u)
   		\EndFor
   \EndWhile                        
  \end{algorithmic}
  \label{alg:merge}
\end{algorithm}
\end{itemize}
\end{frame}