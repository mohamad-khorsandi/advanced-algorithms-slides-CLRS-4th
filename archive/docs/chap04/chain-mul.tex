\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
مسئلهٔ ضرب زنجیره‌ای ماتریس‌ها
\fn{1}{Matrix-chain multiplication problem}
 به صورت زیر است. می‌خواهیم دنباله (زنجیره)ای از n ماتریس
\m{\langle A_1, A_2, \cdots, A_n \rangle}
را در هم ضرب کنیم. این ماتریس‌ها الزاماً ماتریس‌های مربعی نیستند و هدف این است که در این ضرب ماتریسی کمترین تعداد عملیات ضرب استفاده شود.
\item[-]
ضرب ماتریس‌ها شرکت پذیر
\fn{2}{associative}
، بدین معنی که پرانتز گذاری به هر نحوی انجام می‌شود، جواب ضرب ماتریسی تغییر نخواهد کرد.
\end{itemize}
\end{frame}


\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
الگوریتم ضرب دو ماتریس
\m{A(a_{ij})}
و
\m{B(b_{ij})}
به صورت زیر است. نتیجه ضرب این دو ماتریس در ماتریس
\m{C(c_{ij})}
ذخیره می‌شود.
\begin{algorithm}[H]\alglr
  \caption{Matrix Multiplication} 
  \begin{algorithmic}[1]
   \Func{Rectangular-Matrix-Multiply}{A, B, C, p, q, r}
     \For{i = 1 to p}
     	\For{j = 1 to r}
     		\For{k = 1 to q}
      			\State c[i,j] += a[i,k] * b[k,j]
     		\EndFor
     	\EndFor     		      			
     \EndFor                            
  \end{algorithmic}
  \label{alg:merge}
\end{algorithm}
\item[-]
برای اینکه ضرب ماتریسی درست باشد لازم است ابعاد ماتریس A برابر با
\m{p \times q}
و ابعاد ماتریس B برابر با
\m{q \times r}
باشد و ابعاد ماتریس حاصلضرب C در اینصورت برابر با
\m{p \times r}
خواهد بود. تعداد عملیات ضرب انجام شده برابر است با
\m{pqr}.
\end{itemize}
\end{frame}


\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
زنجیره ضرب ماتریسی
\m{A_1 \cdot A_2 \cdot A_3}
را در نظر بگیرید. فرض کنید ماتریس
\m{A_1}
با ابعاد
\m{10 \times 100}
، ماتریس
\m{A_2}
با ابعاد
\m{100 \times 5}
و ماتریس
\m{A_3}
با ابعاد
\m{5 \times 50}
باشد. اگر پرانتز گذاری به صورت
\m{((A_1A_2)A_3)}
باشد، تعداد
\m{10 \times 100 \times 5 = 5000}
عملیات ضرب برای ضرب
\m{A_1A_2}
و تعداد
\m{10 \times 5 \times 50 = 2500}
عملیات ضرب برای ضرب
\m{A_3}
در حاصلضرب
\m{A_1A_2}
باید انجام شود. بنابراین نیاز به انجام
\m{7500}
عملیات ضرب است.
\item[-]
حال فرض کنید پرانتز گذاری به صورت
\m{(A_1(A_2A_3))}
باشد. در اینصورت نیاز به انجام
\m{100 \times 5 \times 50 = 25000}
عملیات ضرب برای ضرب
\m{A_2A_3}
و نیاز به انجام 
\m{10 \times 100 \times 50 = 50000}
عملیات ضرب
برای ضرب
\m{A_1}
در حاصلضرب 
\m{A_2 A_3}
است،
بنابراین در مجموع نیاز به انجام
\m{75000}
عملیات ضرب است. بنابراین با استفاده از پرانتز گذاری اول، عملیات ضرب ۱۰ برابر سریع‌تر انجام می‌شود.
\end{itemize}
\end{frame}


\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
مسئله ضرب زنجیره‌ای ماتریس‌ها
را به صورت زیر بیان می‌کنیم :\\
زنجیرهٔ n ماتریس
\m{\langle A_1, A_2, \cdots, A_n \rangle}
را در نظر بگیرید، به طوری‌که به ازای
\m{i = 1,2, \cdots , n}
، ابعاد ماتریس
\m{A_i}
برابر است با
\m{p_{i-1} \times p_i}
. ضرب
\m{A_1 \cdot A_2 \cdots A_n}
را طوری پرانتز گذاری کنید که تعداد ضرب‌ها در عملیات ضرب این زنجیرهٔ ماتریسی حداقل باشد. ابعاد ورودی مسئله به صورت
\m{\langle p_0, p_1, p_2, \cdots, p_n \rangle}
داده شده‌اند.
\item[-]
در مسئله ضرب زنجیره‌ای ماتریس‌ها نمی‌خواهیم حاصلضرب ماتریس‌ها را به دست آوریم بلکه تنها می‌خواهیم ترتیب ضرب را به گونه‌ای به دست آوریم که هزینه ضرب به حداقل برسد. معمولا زمانی که صرف پیدا کردن پرانتز گذاری بهینه می‌شود ارزش هزینه کردن دارد، چرا که ممکن است ضرب ماتریس‌ها به صورت ترتیبی هزینهٔ گزافی به کاربر تحمیل کند.
\end{itemize}
\end{frame}


\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
قبل از اینکه این مسئله را حل کنیم، بررسی می‌کنیم چند پرانتز گذاری متفاوت وجود دارد. در واقع یک الگوریتم ساده برای حل این مسئله این است که هزینهٔ همهٔ پرانتز گذاری‌ها را با یکدیگر مقایسه کنیم ولی از آنجایی که تعداد پرانتز‌ گذاری‌ها بسیار زیاد است، بررسی همهٔ حالات مقدور نیست.
\item[-]
فرض کنید تعداد کل حالات برای پرانتز گذاری n ماتریس برابر باشد با
\m{P(n)}.
وقتی
\m{n = 1}
تنها یک ماتریس در زنجیره وجود دارد و بنابراین تنها یک حالت برای پرانتز گذاری وجود دارد. وقتی
\m{n \geqslant 2}
باشد، درواقع عبارت می‌تواند به دو قسمت شکسته شود به طوری‌که هر قسمت به طور جداگانه پرانتز گذاری شود. تعداد کل حالت‌های پرانتز گذاری برابر است با ضرب تعداد حالات پرانتز گذاری قسمت اول ضرب در تعداد حالت‌های پرانتز گذاری قسمت دوم.
\end{itemize}
\end{frame}


\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
این زنجیره می‌تواند به شکل‌های متعددی به دو قسمت تقسیم شود که با احتساب همهٔ حالت‌ها عبارت زیر را برای تعداد کل حالت‌های پرانتز گذاری به دست می‌آوریم.
\begin{align*}
\m{P(n)} = \left\{ \begin{array}{lr}
\m{1} & \m{n = 1}~~ \text{اگر}\\
\m{\sum_{k = 1}^{n - 1} P(k) P(n-k)} & \m{n \geqslant 2}~~ \text{اگر}
\end{array}\right.
\end{align*}
\item[-]
با حل این رابطهٔ بازگشتی به دست می‌آید
\m{P(n) = \Omega (2^n)}.
در واقع
\m{P(n)}
دنبالهٔ اعداد کاتالان
\fn{1}{catalan numbers}
(1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, ...)
را می‌سازد که رشد آن نمایی است و بنابراین به ازای n ‌های بسیار بزرگ، بررسی کردن همهٔ حالت‌ها در عمل غیرممکن است.
\end{itemize}
\end{frame}


\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
حال از روش برنامه‌ریزی پویا برای بهینه‌سازی پرانتز گذاری زنجیرهٔ ماتریسی استفاده می‌کنیم. یک الگوریتم به روش برنامه‌ریزی پویا برای یک مسئلهٔ بهینه‌سازی از چهار مرحله تشکیل شده است :
\item[۱-]
توصیف ساختار جواب بهینه بر اساس جواب بهینه زیرمسئله‌ها و بررسی اصل بهینگی
\item[۲-]
تعریف کردن مقدار جواب بهینه به طور بازگشتی
\item[۳-]
محاسبه کردن مقدار جواب بهینه
\item[۴-]
ساختن جواب بهینه توسط اطلاعات محاسبه شده
\end{itemize}
\end{frame}


\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
برای حل یک مسئلهٔ بهینه‌سازی توسط برنامه‌ریزی پویا باید مسئله دارای زیرساختار بهینه
\fn{1}{optimal substructure}
 باشد یا به عبارت دیگر اصل بهینگی
\fn{2}{principle of optimality}
  در آن برقرار باشد.
\item[-]
یک مسئله دارای زیرساختار بهینه است اگر جواب بهینه برای یک مسئله، شامل جواب‌های زیرمسئله‌ها باشد. به عبارت دیگر اگر جواب یک مسئلهٔ بهینه‌سازی را به دست آوریم، باید بتوانیم از جواب آن برای زیرمسئله‌ها نیز استفاده کنیم.
\item[-]
برای مثال مسئله کوتاهترین مسیر در گراف دارای زیرساختار بهینه است.
اگر کوتاهترین مسیر از x به y را به دست آوریم به طوری که مسیر از z عبور کند، کوتاهترین مسیر از x به z  و همچنین کوتاهترین مسیر از z به y نیز در جواب مسئله به دست آمده است.
\item[-]
اما مسئله بلندترین مسیر دارای زیرساختار بهینه نیست.
اگر بلندترین مسیر از x به y را به دست آوریم به طوری که مسیر از z عبور کند، نمی‌توانیم بگوییم بلندترین مسیر از z به y نیز در جواب مسئله است، زیرا ممکن است بلندترین مسیر از z به y از x عبور کند.
\end{itemize}
\end{frame}


\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
(گام ۱) توصیف ساختار جواب بهینه بر اساس جواب زیرمسئله‌ها و بررسی اصل بهینگی:
\item[-]
اولین مرحله در برنامه‌ریزی پویا تشخیص دادن ساختاری از مسئله است که در زیر مسئله‌ها نیز تکرار می‌شود. به عبارت دیگر اگر مسئله را برای یک زیر مسئله حل کنیم، باید بتوانیم با استفاده از اطلاعات زیر مسئله، مسئله را حل کنیم.
\item[-]
فرض کنید به ازای
\m{i \leqslant j}
ماتریس
\m{A_{i : j}}
از ضرب ماتریس‌های
\m{A_i A_{i+1} \cdots A_j}
به دست بیاید. اگر
\m{i = j}
باشد تنها یک پرانتز گذاری وجود دارد، اما اگر
\m{i < j}
باشد آنگاه برای پرانتز گذاری این عبارت می‌توانیم آن را به دو قسمت
\m{A_{i : k}}
و
\m{A_{k+1 : j}}
تقسیم کنیم به طوری‌که
\m{ i \leqslant k < j} .
با ضرب این دو ماتریس در یکدیگر، حاصل
\m{A_{i : j}}
را به دست می‌آوریم.
هزینهٔ پرانتز گذاری
\m{A_{i : j}}
برابر است با هزینه پرانتز گذاری
\m{A_{i : k}}
به علاوهٔ هزینهٔ پرانتز گذاری
\m{A_{k+1 : j}}
به علاوهٔ هزینهٔ ضرب دو قسمت در یکدیگر.
\end{itemize}
\end{frame}


\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
مسئلهٔ ضرب زنجیره‌ای ماتریس‌ها دارای زیرساختار بهینه است. به عبارت دیگر اگر یک پرانتزگذاری برای 
\m{A_{i:j}}
پیدا کنیم به طوری که به دو قسمت 
\m{A_{i:k}}
و
\m{A_{k+1:j}}
تقسیم شود، پرانتزگذاری
\m{A_{i:k}}
نیز بهینه است (به همین ترتیب پرانتزگذاری 
\m{A_{k+1:j}}
نیز بهینه است)
.
\item[-]
اثبات: فرض کنیم پرانتزگذاری 
\m{A_{i:j}}
 بهینه باشد و پرانتزگذاری
\m{A_{i:k}}
بهینه نباشد. در اینصورت می‌توانیم یک پرانتزگذاری بهینه برای 
\m{A_{i:k}}
پیدا کنیم و آن را در 
\m{A_{i:j}}
استفاده کنیم و یک پرانتزگذاری با هزینه کمتر برای 
\m{A_{i:j}}
به دست آوریم که با فرض اولیه در تناقض است. 
\end{itemize}
\end{frame}


\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
به طور خلاصه، اگر پرانتزگذاری بهینه برای
\m{A_{i : j}}
را پیدا کنیم، این پرانتزگذاری الزاما از دو پرانتزگذاری
\m{A_{i : k}}
و
\m{A_{k+1 : j}}
تشکیل شده است و الزاما پرانتزگذاری‌های
\m{A_{i : k}}
و
\m{A_{k+1 : j}}
نیز بهینه هستند.
\item[-]
بدین دلیل می‌توانیم از برنامه‌ریزی پویا استفاده کنیم، زیرا می‌توانیم هزینه‌های پرانتزگذاری‌های
\m{A_{i : k}}
و
\m{A_{k+1 : j}}
را از قبل ذخیره کنیم، و از این هزینه‌ها برای محاسبهٔ پرانتزگذاری
\m{A_{i : j}}
استفاده کنیم.
\end{itemize}
\end{frame}


\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
بنابراین باید مقدار 
\m{k}
 را پیدا کنیم به طوری‌که هزینهٔ پرانتز گذاری
\m{A_{i : k}}
به علاوهٔ هزینهٔ‌ پرانتزگذاری
\m{A_{k+1 : j}}
به علاوهٔ هزینهٔ ضرب
\m{A_{i : k}}
در
\m{A_{k+1 : j}}
بهینه باشد. آنگاه پرانتز گذاری
\m{A_{i : j}}
نیز بهینه خواهد بود.
\item[-]
پس برای حل مسئله یافتن هزینهٔ پرانتزگذاری بهینه برای
\m{A_{i : j}}
باید به ازای همهٔ 
\m{k}
 ها
هزینهٔ‌ پرانتزگذاری بهینه برای 
\m{A_{i : k}}
و 
\m{A_{k+1 : j}}
را محاسبه و با هزینهٔ ضرب
\m{A_{i : k}}
در
\m{A_{k+1 : j}}
جمع کنیم.
آنگاه از این میان 
\m{k}
 را به گونه‌ای انتخاب کنیم که هزینهٔ پرانتزگذاری 
بهینه باشد (تعداد ضرب‌های پرانتزگذاری
\m{A_{i : j}}
 کمترین مقدار ممکن باشد).
\iffalse
\item[-]
عبارت قبل را می‌توانیم به صورت زیر با استفاده از برهان خلف ثابت کنیم. فرض کنیم پرانتز گذاری
\m{A_{i : j}}
بهینه نباشد. این بدین معناست که یک پرانتز گذاری با هزینه کمتر وجود دارد. اما اگر یک پرانتز گذاری بهینه‌تر وجود داشته باشد می‌توان عبارت
\m{A_{i : j}}
را به دو قسمت تقسیم کرد و یک پرانتز گذاری بهتر برای
\m{A_{i : k}}
و
\m{A_{k+1 : j}}
پیدا کرد که در اینصورت به تناقض می‌رسیم.
\fi
\end{itemize}
\end{frame}



\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
(گام ۲) تعریف کردن مقدار جواب بهینه به طور بازگشتی :
\item[-]
فرض کنید
\m{m[i,j]}
حداقل تعداد ضرب‌های مورد نیاز برای محاسبه
\m{A_{i : j}}
باشد. حداقل تعداد ضرب‌های مورد نیاز برای کل n ماتریس یعنی
\m{A_{1 : n}}
برابراست با
\m{m[1,n]}.
\item[-]
می‌خواهیم یک عبارت بازگشتی برای مقدار
\m{m[i,j]}
محاسبه کنیم.
\item[-]
اگر
\m{i = j}
باشد، هزینه‌ای وجود ندارد، بنابراین
\m{m[i,j] = 0}.
\item[-]
اگر
\m{i < j}
باشد، از ساختار جواب بهینه برای زیر مسئله‌ها استفاده می‌کنیم. فرض کنید یک پرانتز گذاری بهینه حاصلضرب
\m{A_{i : j}}
را به دو قسمت
\m{A_{i : k}}
و
\m{A_{k+1 : j}}
تقسیم می‌کند به طوری‌که
\m{ i \leqslant k < j}.
بنابراین
\m{m[i,j]}
برابر است با هزینه
\m{m[i,k]}
برای محاسبه
\m{A_{i : k}}
به علاوه هزینه
\m{m[k+1,j]}
برای محاسبهٔ
\m{A_{k+1 : j}}
به علاوه هزینهٔ ضرب دو قسمت در یکدیگر. حاصلضرب
\m{A_{i : k} A_{k+1 : j}}
به تعداد
\m{p_{i-1} p_k p_j}
عملیات ضرب نیاز دارد. بنابراین داریم :
\begin{flushleft}
\m{m[i,j] = m[i,k] + m[k+1,j] + p_{i-1} p_k p_j}
\end{flushleft}
\end{itemize}
\end{frame}

\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
در رابطه قبل فرض کردیم مقدار k را می‌دانیم، اما از آنجایی که مقدار k ناشناخته است باید همهٔ مقادیر k به ازای
\m{k = i, i+1, \cdots , j-1}
امتحان کنیم تا مقدار بهینه
\m{m[i,j]}
را به‌دست آوریم. بنابراین رابطهٔ بازگشتی را در حالت کلی به صورت زیر می‌نویسیم.
\begin{align*}
\m{m[i,j]} = \left\{ \begin{array}{lr}
\m{0} & \m{i = j}~~ \text{اگر}\\
\m{min \{m[i,k] + m[k+1,j] + p_{i-1} p_k p_j : i \leqslant k < j} \} & \m{i < j}~~ \text{اگر}
\end{array}\right.
\end{align*}
\end{itemize}
\end{frame}


\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
(گام ۳) محاسبه کردن مقدار جواب بهینه:
\item[-]
حال می‌توانیم برنامه‌ای بنویسیم که به صورت بازگشتی رابطهٔ بازگشتی به دست آمده را محاسبه کند تا حداقل مقدار
\m{m[1,n]}
را به‌دست آوریم. این الگوریتم بازگشتی برای محاسبه، زمانی از مرتبه نمایی نیاز دارد، پس از این الگوریتم نیز در عمل برای n های بسیار بزرگ نمی‌توانیم استفاده کنیم.
\item[-]
مشکل الگوریتم بازگشتی این است که برخی از زیر مسئله‌ها یعنی برخی از
\m{m[i,j]}
‌ها ممکن است چندبار محاسبه شوند.
برای مثال برای دو پرانتزگذاری
\m{(A_{p:q})(A_{q+1})}
و
\m{(A_{p-1})(A_{p:q})}
دو بار باید هزینه پرانتزگذاری بهینه
\m{A_{p:q}}
محاسبه شود.
\item[-]
اما تعداد کل زیر مسئله‌ها به ازای
\m{1 \leqslant i \leqslant j \leqslant n}
برابراست با
\ath{n^2} .
%\begin{align*}
%\left( \begin{array}{c} \m{n} \\ \m{2} \end{array} \right) + \m{n} = \ath{n^2}
%\end{align*}
\iffalse
\item[-]
در واقع تعداد کل جفت‌های i و j هنگامی که برابر نباشند برابر است با 
\m{\binom{n}{2}} . 
اگر i و j برابر باشند، تعداد کل حالات برابر است با 
\m{n} .
\fi
\end{itemize}
\end{frame}


\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
به جای حل رابطه بازگشتی با استفاده از یک الگوریتم بازگشتی، آن را توسط جدولی حل می‌کنیم که مقادیر
\m{m[i,j]}
را از پایین به بالا محاسبه کند، بدین معنی که از
\m{m[1,1]}
شروع می‌کنیم و به ترتیب زیر مسئله‌های بزرگ‌تر را با استفاده از زیر مسئله‌های کوچکتر حل می‌کنیم.
\item[-]
به این روش حل مسئله
روش برنامه‌ریزی پویا گفته می‌شود.
در برنامه‌ریزی پویا مسئله به زیرمسأله‌ها شکسته شده، و حل مسئله با
 شروع از کوچکترین زیر مسئله‌ها آغاز می‌شود تا جواب مسئلهٔ اصلی با استفاده از زیر مسئله‌های کوچکتر محاسبه می‌شود.
\end{itemize}
\end{frame}


\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
الگوریتم زیر، مسئلهٔ بهینه‌سازی ضرب ماتریسی را به روش برنامه‌ریزی پویا حل می‌کند.
\end{itemize}
\end{frame}


\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{algorithm}[H]\alglr
  \caption{Matrix Chain} 
  \begin{algorithmic}[1]
   \Func{Matrix-Chain-Order}{p , n}
     \State let m[1:n , 1:n] and s[1:n , 1:n] be new tables
     \For{i = 1 to n} \LeftComment{ chain length 1}
     	\State m[i,i] = 0 
     \EndFor
     \For{t = 2 to n} \LeftComment{t is the chain length}
        \For{i = 1 to n - t + 1}  \LeftComment{chain begins at Ai}
         \State j = i + t - 1 \LeftComment{chain ends at Aj}
         \State m[i,j] = $\infty$
         \For{k = i to j - 1} \LeftComment{try A[i:k] A[k+1 : j]}
         			\State q = m[i,k] + m[k+1,j] + p[i-1]*p[k]*p[j]
         			\If{q < m[i,j]}
         				\State m[i,j] = q \LeftComment{remember this cost}
         				\State s[i,j] = k  \LeftComment{remember this index}
         			\EndIf
         	\EndFor
         \EndFor
      \EndFor
  \State \Return m and s            
  \end{algorithmic}
  \label{alg:merge}
\end{algorithm}
\end{frame}


\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
زمان مورد نیاز برای حل این مسئله
\m{O(n^3)}
و حافظه مورد نیاز برای حل آن
\m{\ath{n^2}}
است، زیرا نیاز به نگهداری جدول برای محاسبه زیر مسئله‌ها می‌باشد.
\item[-]
با استفاده از برنامه‌ریزی پویا، زمان حل یک مسئله را از زمان نمایی به زمان چند جمله‌ای درجه سوم کاهش دادیم.
\end{itemize}
\end{frame}


\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
(گام ۴) ساختن جواب بهینه توسط اطلاعات محاسبه شده :
\item[-]
گرچه در گام قبل مقدار بهینه برای تعداد ضرب‌ها در یک زنجیرهٔ ماتریسی را محاسبه کردیم، اما روش پرانتزگذاری ماتریس‌ها را به دست نیاوردیم.
\item[-]
جدول
\m{s[1 : n , 1 : n]}
که در الگوریتم قبل محاسبه کردیم اطلاعات مورد نیاز برای جواب بهینه را نگهداری می‌کند. هر عنصر
\m{s[i , j]}
مقدار k را ذخیره می‌کند، به طوری که
\m{A_{i : j}}
به دو قسمت
\m{A_{i : k}}
و
\m{A_{k+1 : j}}
برای ضرب بهینه تقسیم می‌شود.
\end{itemize}
\end{frame}


\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
الگوریتم زیر پرانتز گذاری را برای مسئله ضرب زنجیرهٔ ماتریس‌ها انجام می‌دهد.
\begin{algorithm}[H]\alglr
  \caption{Print Optimal Parentheses} 
  \begin{algorithmic}[1]
   \Func{Print-Optimal-Parens}{s, i, j}
   \If{i == j}
   		\State print "A"i
   		\Else 
   		\State print "("
   		\State Print-Optimal-Parens (s, i, s[i, j])
   		\State Print-Optimal-Parens (s, s[i, j]+1, j)
   		\State print ")"
   	\EndIf
  \end{algorithmic}
  \label{alg:merge}
\end{algorithm}   
\end{itemize}
\end{frame}


\begin{frame}{‌ضرب زنجیره‌ای ماتریس‌ها}
\begin{itemize}\itemr
\item[-]
برای حل یک مسئله توسط روش برنامه‌ریزی پویا، مسئله باید دو ویژگی داشته باشد.
\item[-]
ویژگی اول این است که مسئله را باید بتوان با استفاده از جواب زیر مسئله‌های آن به دست آورد. درواقع باید بتوان برای مسئله زیر مسئله‌هایی پیدا کرد که ساختار آنها شبیه مسئله اصلی است.
به عبارت دیگر مسئله باید دارای زیرساختار بهینه باشد.
\item[-]
 ویژگی دوم این است که اگر بخواهیم مسئله را توسط الگوریتم بازگشتی حل کنیم باید زیر مسئله‌ها همپوشانی داشته باشند. بدین ترتیب جدول برنامه‌ریزی پویا راه‌حلی برای جلوگیری از محاسبات تکراری در این همپوشانی‌ها خواهد بود.
\end{itemize}
\end{frame}