%%%%%%%%%%%%%%%%%%%%%%%%%
\section{مقدمه}
%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{مقدمه}
\begin{itemize}\itemr
\item[-]
کلمهٔ الگوریتم از نام دانشمند ایرانی محمدبن موسی الخوارزمی گرفته شده است.
خوارزم منطقه‌ای است در آسیای مرکزی که در حال حاضر در ازبکستان و ترکمنستان قرار دارد و در کنار دریاچهٔ آرال (دریاچهٔ خوارزم) قرار گرفته است.
\item[-]
خوارزمی کتاب الجبرو المقابله را نیز به تألیف رسانده است که کلمه جبر
\fn{1}{Algebra}
در زبان انگلیسی نیز از همین کتاب گرفته شده است.
جبر در عربی معنای شکسته بندی است و مقابله به معنی در مقابل یکدیگر قرار دادن است. احتمالا به دلیل این که معادلات جبری متغیرهای متفاوت را جمع آوری می‌کنند و در مقابل یکدیگر قرار می‌دهند، به علم حل معادلات، جبر و مقابله گفته می‌شده است. خوارزمی روش‌هایی برای حل معادلات جبری در کتاب خود ابداع کرده است که به روش‌های الخوارزمی و بعدها در غرب به روش‌های الگوریتمی معروف شده است.
\end{itemize}
\end{frame}


\begin{frame}{مقدمه}
\begin{itemize}\itemr
\item[-]
کلمهٔ الگوریتم در بسیاری از کتاب‌ها برای الگوریتم اقلیدس
\fn{1}{Euclid's algorithm}
که برای پیدا کردن بزرگ‌ترین مقسوم‌علیه مشترک
\fn{2}{Greatest common divisor}
دو عدد به‌کار می‌رود و در کتاب اصول اقلیدس
\fn{3}{Euclid's Element}
توصیف شده است، استفاده شده است.
\item[-]
الگوریتم پیدا کردن بزرگ‌ترین مقسوم‌علیه مشترک را می‌توانیم به صورت زیر وصف کنیم.\\
۱. (پیدا کردن باقیمانده.) عدد
m
را بر
n
تقسیم می‌کنیم. فرض کنید باقیمانده
r 
باشد. در اینصورت خواهیم داشت
\m{0 \leqslant r < n} .\\
۲. (آیا باقیمانده صفر است؟) اگر
\m{r = 0}
، الگوریتم پایان می‌یابد و
n
جواب مسئله است.\\
۳. (کاهش.) قرار می‌دهیم
\m{m \leftarrow n}
و
\m{n \leftarrow r}
و به مرحلهٔ ۱ می‌رویم.
\end{itemize}
\end{frame}


\begin{frame}{مقدمه}
\begin{itemize}\itemr
\item[-]
الگوریتم در واقع یک روند
\fn{1}{procedure}
یا دستورالعمل
\fn{2}{recipe}
برای حل یک مسئلهٔ محاسباتی است.
\item[-]
به طور غیر رسمی می‌توانیم بگوییم یک الگوریتم در واقع یک روند محاسباتی گام‌به‌گام است که مجموعه‌ای از مقادیر را که ورودی الگوریتم نامیده می‌شوند دریافت می‌کند و مجموعه‌ای از مقادیر را که خروجی الگوریتم نامیده می‌شوند در زمان محدود تولید می‌کند. بنابراین یک الگوریتم دنباله‌ای است از گام‌های محاسباتی که ورودی‌ها را به خروجی تبدیل می‌کند.
\end{itemize}
\end{frame}


\begin{frame}{مقدمه}
\begin{itemize}\itemr
\item[-]
می‌توان گفت یک الگوریتم ابزاری است برای حل یک مسئله محاسباتی معین.
\item[-]
یک مسئله با تعدادی گزاره رابطهٔ بین ورودی‌ها و خروجی‌ها را در حالت کلی مشخص می‌کند. یک نمونه از مسئله، در واقع با جایگذاری اعداد و مقادیر برای مسئله کلی به دست می‌آید. یک الگوریتم روشی گام‌به‌گام را شرح می‌دهد که با استفاده از آن در حالت کلی برای همهٔ نمونه‌های یک مسئله، خروجی‌ها با دریافت ورودی‌ها تولید شوند.
بنابراین روند یک الگوریتم در رابطهٔ بین ورودی‌ها و خروجی‌ها صدق می‌کند.
\item[-]
به عنوان مثال، فرض کنید می‌خواهیم دنباله‌ای از اعداد را با ترتیب صعودی مرتب کنیم. این مسئله که مسئله مرتب سازی
\fn{1}{sorting problem}
نام دارد، یک مسئله بنیادین در علوم کامپیوتر به حساب می‌آید که منشأ به وجود آمدن بسیاری از روش‌های طراحی الگوریتم نیز می‌باشد.
\end{itemize}
\end{frame}


\begin{frame}{مقدمه}
\begin{itemize}\itemr
\item[-]
مسئله مرتب سازی را به طور رسمی به صورت زیر تعریف می‌کنیم.
\item[-]
ورودی مسئله مرتب سازی عبارت است از دنباله‌ای از n عدد به صورت
\m{\enc{a_1,a_2,...,a_n}}
و خروجی مسئله عبارت است از دنباله‌ای به صورت
\m{\enc{a'_1,a'_2,...,a'_n}}
که از جابجا کردن عناصر دنبالهٔ ورودی به‌دست آمده است به طوری که
\m{a'_1 \leq a'_2 \leq ... \leq a'_n}
.
\item[-]
بنابراین به ازای دنباله ورودی
\m{\enc{58,42,36,42}}
دنباله خروجی
\m{\enc{36,42,42,58}}
جواب مسئله است.
\item[-]
یک نمونه از یک مسئله
\fn{1}{instance of a problem}
تشکیل شده است از یک ورودی معین و شرح ویژگی خروجی مسئله. بنابراین 
 دنبالهٔ ورودی
 \m{\enc{58,42,36,42}}
  به علاوه شرح مسئله مرتب سازی یک نمونه از مسئلهٔ مرتب سازی نامیده می‌شود.
\end{itemize}
\end{frame}

\begin{frame}{مقدمه}
\begin{itemize}\itmsep{5mm}
\item[-]
بنابراین به طور خلاصه،
یک مسئله تشکیل شده است از (۱) توصیفی از چند پارامتر (متغیر آزاد)، که ورودی‌های مسئله نامیده می‌شوند و (۲) گزاره‌هایی برای بیان رابطهٔ ورودی‌ها و مقادیر خروجی‌ (جواب) مسئله، یا به عبارت دیگر
ویژگی‌هایی که جواب مسئله دارد.
\item[-]
یک پارامتر کمیتی است که مقدار آن مشخص نشده و توسط حروف و یا کلمات، نامی بر آن نهاده شده است.
\item[-]
یک نمونهٔ مسئله با تعیین مقادیر پارامترهای مسئله به دست می‌آید.
\item[-]
یک الگوریتم، روندی گام به گام است برای پیدا کردن جواب یک مسئله است.
\end{itemize}
\end{frame}

\begin{frame}{مقدمه}
\begin{itemize}\itemr
\item[-]
سرعت اجرای مسئله مرتب سازی به اندازه ورودی یعنی تعداد عناصر دنباله نامرتب و روند الگوریتم بستگی دارد.
\item[-]
الگوریتم‌های زیادی برای حل یک مسئله وجود دارند که هر کدام می‌توانند مزایا و معایبی داشته باشند. به طور مثال یک الگوریتم از میزان حافظهٔ بیشتری استفاده می‌کند، اما زمان کمتری برای محاسبه نیاز دارد و الگوریتم دیگر با میزان حافظهٔ کمتر در زمان بیشتری محاسبه می‌شود که به فراخور نیاز می‌توان از یکی از الگوریتم‌ها استفاده کرد.
\item[-]
عوامل دیگری مانند معماری کامپیوتر، نوع پردازنده و میزان حافظه نیز در زمان اجرای یک الگوریتم مؤثرترند اما این عوامل فیزیکی هستند و صرف نظر از عوامل فیزیکی می‌توان الگوریتم‌ها را از لحاظ میزان حافظه مورد نیاز و زمان اجرا با یکدیگر مقایسه کرد.
\end{itemize}
\end{frame}


\begin{frame}{مقدمه}
\begin{itemize}\itemr
\item[-]
یک الگوریتم برای یک مسئله محاسباتی درست است اگر به ازای هر نمونه از مسئله که با تعدادی ورودی معین شده است، (۱) توقف کند، بدین که در زمان محدود به اتمام برسد و (۲) خروجی تعیین شده توسط شرح مسئله را تولید کند. می‌گوییم یک الگوریتم درست  یک مسئلهٔ محاسباتی را حل می‌کند.
\item[-]
یک الگوریتم نادرست ممکن است به ازای برخی از ورودی‌ها توقف نکند یا ممکن است به ازای برخی از ورودی‌ها خروجی نادرست تولید کند.
\item[-]
یک الگوریتم را می‌توان با استفاده از یک زبان طبیعی مانند فارسی یا انگلیسی توصیف کرد و یا برای توصیف آن از یک برنامهٔ کامپیوتری یا یک زبان ساده شده مانند فلوچارت یا شبه‌کد استفاده کرد. تنها نیازمندی یک الگوریتم توصیف دقیق گام‌های الگوریتم است و زبان مورد استفاده برای توصیف اهمیتی ندارد.
\end{itemize}
\end{frame}


\begin{frame}{مقدمه}
\begin{itemize}\itemr
\item[-]
یک الگوریتم را به صورت یک فلوچارت
\fn{1}{flowchart}
می‌توانیم رسم کنیم.
\item[-]
یک فلوچارت یا روندنما نموداری است که روند انجام کاری را نشان می‌دهد.
\item[-]
یک فلوچارت،الگوریتم را به صورت تصویری به نمایش می‌گذارد. در یک فلوچارت معمولاً برای گام‌های محاسباتی از مستطیل و برای گام‌های شرطی از بیضی یا لوزی استفاده می‌شود. همچنین در گام‌هایی که ورودی از کاربر گرفته می‌شود یا خروجی برای نمایش به کاربر چاپ می‌شود از متوازی‌الاضلاع یا اشکالی شبیه به مستطیل استفاده می‌شود. هر گام به گام بعدی توسط یک علامت فلش متصل می‌شود. شروع و پایان را معمولا با دایره نشان می‌دهند.
\end{itemize}
\end{frame}


\begin{frame}{مقدمه}
\begin{itemize}\itemr
\item[-]
برای مثال الگوریتم اقلیدس را می‌توان به صورت زیر رسم کرد.
%flochart
\begin{figure}[h]
\input{figs/chap02/euclid}
\end{figure}
\end{itemize}
\end{frame}

\iffalse
\begin{frame}{مقدمه}
\begin{itemize}\itemr
\item[-]
در الگوریتم‌ها معمولا از علامت
\m{\leftarrow}
یا
\m{:=}
برای عملیات انتساب استفاده می‌شود. برای مثال
\m{m \leftarrow n}
یعنی
\m{m}
را با مقدار فعلی
\m{n}
مقدار دهی می‌کنیم.
\item[-]
به عنوان مثال دیگر، برای افزایش مقدار یک متغیر به اندازهٔ یک واحد می‌نویسیم
\m{n \leftarrow n+1}
یعنی مقدار
\m{n}
برابراست با مقدار فعلی
\m{n}
به علاوهٔ یک. معمولاً این عبارت را به این صورت می‌خوانیم : مقدار
\m{n}
برابر می‌شود با
\m{n+1}
.
\item[-]
معمولاً از علامت
\m{==}
یا
\m{=}
برای تساوی استفاده می‌شود. برای مثال می‌توانیم بپرسیم آیا مقدار
\m{m}
برابراست با مقدار
\m{n}
و برای مثال می‌نویسیم اگر
\m{m == n}
به مرحله بعد می‌رویم.
\item[-]
در نشانه گذاری ریاضی معمولاً دنباله‌ها را با استفاده از اندیس‌ها نمایش می‌دهیم برای مثال دنباله
\m{v_1, v_2, \cdots , v_n}
یک دنباله از
n
متغیر است. در الگوریتم‌ها معمولاً از عملگر زیرنویس
\fn{1}{subscript}
که با دو براکت باز و بسته
\m{[~]}
نمایش داده می‌شود استفاده می‌کنیم. بنابراین
i
امین عنصر دنبالهٔ
\m{v_1, \cdots , v_n}
را به صورت
\m{v[i]}
نمایش می‌دهیم.
\end{itemize}
\end{frame}
\fi


\begin{frame}{مقدمه}
\begin{itemize}\itemr
\item[-]
الگوریتم‌ها در زمینه‌های زیاد و متنوعی کاربرد دارند.
\item[-]
به عنوان مثال در پروژه ژنوم‌های انسانی هدف پیدا کردن الگوهای ژن‌ها در دی‌ان‌ای
\fn{1}{DNA}
 انسان است که برای این کار از الگوریتم‌های کامپیوتری استفاده می‌شود. به عنوان چند مثال دیگر می‌توان از الگوریتم کوتاهترین مسیر برای مسیریابی بسته‌های اینترنتی در شبکه‌های کامپیوتری، الگوریتم‌های رمز نگاری برای تبادل امن اطلاعات، الگوریتم‌های تخصیص منابع و زمانبندی در کاربردهایی مانند زمانبندی پروازها و تخصیص خلبان و خدمه به هواپیماها با کمترین هزینه ممکن و الگوریتم‌های فشرده سازی داده‌ها نام برد.
\item[-]
معمولاً یک مسئلهٔ محاسباتی راه حل‌های زیادی دارد که بنابر اهمیت معیارهای مورد نیاز استفاده کنندهٔ الگوریتم، الگوریتمی انتخاب می‌شود که در یک یا چند معیار مورد نظر بهترین باشد. برای مثال یک الگوریتم ممکن است در زمان کمتری اجرا شود ولی حافظه بیشتری اشغال کند و الگوریتم دیگر به حافظه کمتری نیاز داشته باشد اما در زمان بیشتری اجرا شود.
\end{itemize}
\end{frame}


\begin{frame}{مقدمه}
\begin{itemize}\itemr
\item[-]
دسته‌ای از مسئله‌های محاسباتی وجود دارند که گرچه برای محاسبهٔ آنها الگوریتم وجود دارد ولی هیچ یک از الگوریتم‌های موجود نمی‌توانند مسئله را در زمان معقول حل کنند. منظور از زمان معقول زمانی است که آنقدر زیاد نباشد که حل آن مسئله در آن مقدار زمان بی‌معنی شود و دریافت جواب پس از آن زمان بی استفاده باشد. بعدها این مفهوم معقول را به طور رسمی و دقیق تعریف خواهیم کرد.
\item[-]
این دسته از مسئله‌ها ان‌پی کامل
\fn{1}{NP-Complete problems}
 نامیده می‌شوند. گرچه برای این دسته از مسائل هیچ الگوریتمی در زمان معقول پیدا نشده است، اما هیچ‌کس نیز اثبات نکرده است که برای آنها نمی‌توان الگوریتمی در زمان معقول
\fn{2}{reasonable}
  پیدا کرد. بنابراین هیچ‌کس نمی‌داند آیا برای مسائل ان‌پی کامل الگوریتم کارامد
\fn{3}{efficient}
   وجود دارد یا خیر.
\end{itemize}
\end{frame}

\begin{frame}{مقدمه}
\begin{itemize}\itemr
\item[-]
یک ویژگی دیگر مسائل ان‌پی کامل این است که اگر برای یکی از آنها الگوریتم کارامد پیدا شود، برای همهٔ آنها الگوریتم کارامد پیدا خواهد شد چرا که این مسائل قابل تبدیل به یکدیگرند.
\item[-]
فرض کنید یک مسئله جدید به ما داده شده است. ابتدا تلاش می‌کنیم برای آن مسئله یک الگوریتم کارامد پیدا کنیم. چنانچه نتوانستیم برای آن الگوریتمی کارامد پیدا کنیم، می‌توانیم سعی کنیم تا اثبات کنیم که مسئله ان‌پی کامل است.
\item[-]
گرچه برای مسئله‌های ان‌پی کامل الگوریتم دقیق کارامد پیدا نشده است، ولی الگوریتم‌های تقریبی
\fn{1}{Approximation algorithms}
 زیادی وجود دارند که خروجی قابل قبولی نزدیک به خروجی مورد انتظار در زمان معقول تولید می‌کنند.
\end{itemize}
\end{frame}


\begin{frame}{مقدمه}
\begin{itemize}\itemr
\item[-]
در سالیان قبل با پیشرفت تکنولوژی سرعت پردازنده‌ها افزایش می‌یافت. در سال‌های اخیر سرعت پردازنده‌ها به حد فیزیکی خود نزدیک شده است، بدین معنا که از لحاظ فیزیکی امکان افزایش سرعت وجود ندارد. بنابراین در تکنولوژی‌های جدید در یک پردازنده از چند واحد پردازشی یا هسته استفاده می‌شود.
\item[-]
برای استفادهٔ بهینه از این پردازنده‌های چند هسته‌ای دسته‌ای از الگوریتم‌ها به نام الگوریتم‌های موازی
\fn{1}{Parallel algorithms}
 به‌وجود آمده‌اند.
\item[-]
در بسیاری از الگوریتم‌ها فرض بر این است که ورودی قبل از شروع الگوریتم در دسترس است اما در برخی مواقع، ورودی به مرور زمان وارد می‌شود. برای مثال در یک سیستم عامل واحدهای کاری در هر لحظه ممکن است به وجود بیایند و الگوریتم بر اساس وضعیت موجود باید تصمیم بگیرد چگونه واحدهای کاری را زمانبندی کند. الگوریتم‌هایی که ورودی را به مرور زمان دریافت می‌کنند الگوریتم‌های برخط
\fn{2}{Online algorithms}
نامیده می‌شوند.
\end{itemize}
\end{frame}



\begin{frame}{‌مرتب سازی درجی}
\begin{itemize}\itemr
\item[-]
یکی از مسائل مهم در علوم و مهندسی کامپیوتر، مسئله مرتب سازی است. یک آرایه از چندین عنصر را در نظر بگیرید. می‌خواهیم عناصر این آرایه را از کوچک به بزرگ مرتب کنیم. به عبارت دیگر اگر آرایه
\m{A = [a_1,a_2, ... ,a_n]}
را داشته باشیم، می‌خواهیم عناصر آرایه یعنی
\m{a_i}
ها
را جابجا کنیم و آرایه خروجی
\m{[a'_1,a'_2, ... ,a'_n]}
را به دست آوریم، به طوری
 که به ازای هر
\m{1 \leq i < n}
داشته باشیم
\m{a'_i \leq a'_{(i+1)}}
.
\end{itemize}
\end{frame}


\begin{frame}{‌مرتب سازی درجی}
\begin{itemize}\itemr
\item[-]
یکی از الگوریتم‌های ارائه شده برای این مسئله الگوریتم مرتب سازی درجی
\fn{1}{insertion sort}
است.
\item[-]
به طور خلاصه این الگوریتم به صورت زیر عمل می‌کند. فرض کنید یک آرایه با n عنصر از درایهٔ ۱ تا درایهٔ k مرتب شده باشد. حال برای مرتب سازی آرایه از درایهٔ ۱ تا درایهٔ 
k+1
باید عنصر
k+1
را در بین عناصر 1 و k طوری قرار دهیم که از عنصر قبلی خود بزرگ‌تر و از عنصر بعدی خود کوچک‌تر باشد. بدین ترتیب آرایه را از درایهٔ ۱ تا k+1 مرتب کرده‌ایم. این کار را تا جایی ادامه می‌دهیم که کل آرایه مرتب شود.
\end{itemize}
\end{frame}


\begin{frame}{‌مرتب سازی درجی}
\begin{itemize}\itemr
\item[-]
به طور خلاصه این الگوریتم را می‌توانیم به صورت زیر بنویسیم.
\begin{algorithm}[H]\alglr
  \caption{Insertion Sort} 
  \begin{algorithmic}[1]
    \Func{Insertion-Sort}{A, n}
    \newline\LeftComment{A is an array of n elements}
      \For{i = 2 \To n}
        \State key = A[i]
        \State j = i - 1
        \While{ j > 0 and A[j] > key }
          \State A[j+1] = A[j]
          \State j = j-1
	\EndWhile
        \State A[j+1] = key
      \EndFor
  \end{algorithmic}
  \label{alg:insertion-sort}
\end{algorithm}
\end{itemize}
\end{frame}


\begin{frame}{‌مرتب سازی درجی}
\begin{itemize}\itemr
\item[-]
این الگوریتم دارای گام‌هایی است که در یک حلقه تکرار می‌شوند تا در نهایت کل آرایه مرتب شود. در هر مرحله اتمام حلقه، قسمتی از آرایه مرتب شده و قسمتی از آرایه نامرتب است و باید در آینده مرتب شود.
\item[-]
یک ویژگی که قبل و بعد از هر تکرار حلقه درست باشد ثابت حلقه
\fn{1}{loop invarint}
گفته می‌شود.
\item[-]
برای مثال ثابت حلقه در الگوریتم مرتب سازی درجی این است که زیر آرایه
\m{A[1:i-1]}
در هر تکرار حلقه قبل از شروع حلقه مرتب است.
\item[-]
ثابت‌های حلقه برای اثبات درستی یک الگوریتم به کار می‌روند. کافی است نشان دهیم که این ثابت حلقه قبل از اولین تکرار حلقه درست است و همچنین اگر قبل از یک تکرار حلقه درست باشد، قبل از تکرار بعدی نیز درست است. در این اثبات در واقع از استقرای ریاضی استفاده می‌کنیم.
همچنین برای اثبات درستی الگوریتم باید نشان دهیم که حلقه پایان می‌پذیرد.
\end{itemize}
\end{frame}
